#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include "auth_utils.h"
#include "snowflake/secure_storage.h"

char** getTotpCodes(const char* seed) {
    char command[512];
    const char *totpGeneratorPath = "/externalbrowser/totpGenerator.js";
    
    snprintf(command, sizeof(command), "node %s %s", totpGeneratorPath, seed ? seed : "");
    
    FILE *pipe = popen(command, "r");
    if (!pipe) {
        return NULL;
    }
    
    char buffer[1024];
    char *output = fgets(buffer, sizeof(buffer), pipe);
    pclose(pipe);
    
    if (!output) {
        return NULL;
    }
    
    char *newline = strchr(output, '\n');
    if (newline) *newline = '\0';
    
    char **codes = malloc(sizeof(char*) * 3);
    codes[0] = codes[1] = codes[2] = NULL;
    
    int count = 0;
    char *token = strtok(output, " ");
    while (token && count < 3) {
        codes[count] = malloc(strlen(token) + 1);
        strcpy(codes[count], token);
        count++;
        token = strtok(NULL, " ");
    }
    
    return codes;
}

void freeTotpCodes(char** codes) {
    if (!codes) return;
    for (int i = 0; i < 3; i++) {
        if (codes[i]) free(codes[i]);
    }
    free(codes);
}

void test_mfa_totp_authentication(void **unused) {
    SF_UNUSED(unused);

    // Setup MFA token cache directory (required for Linux)
    const char* cache_dir = "sf_mfa_cache_test";
    char cache_path[256];
    snprintf(cache_path, sizeof(cache_path), "%s", cache_dir);
    
    // Remove and recreate cache directory with proper permissions
    rmdir(cache_path);
    if (mkdir(cache_path, 0700) != 0 && errno != EEXIST) {
        fail_msg("Failed to create MFA cache directory");
        return;
    }
    
    // Set cache directory environment variable
    if (setenv("SF_TEMPORARY_CREDENTIAL_CACHE_DIR", cache_path, 1) != 0) {
        fail_msg("Failed to set SF_TEMPORARY_CREDENTIAL_CACHE_DIR");
        return;
    }

    SF_CONNECT *sf = snowflake_init();
    set_all_snowflake_attributes(sf);
    
    // Clear any existing MFA token (like mock test does)
    secure_storage_ptr ss = secure_storage_init();
    if (ss) {
        secure_storage_remove_credential(ss, sf->host, getenv("SNOWFLAKE_AUTH_TEST_MFA_USER"), MFA_TOKEN);
        secure_storage_term(ss);
    }
    
    char *mfa_user = getenv("SNOWFLAKE_AUTH_TEST_MFA_USER");
    char *mfa_password = getenv("SNOWFLAKE_AUTH_TEST_MFA_PASSWORD");
    
    printf("DEBUG: MFA_USER = %s\n", mfa_user ? mfa_user : "NULL");
    printf("DEBUG: Cache directory = %s\n", cache_path);
    
    if (!mfa_user || !mfa_password) {
        snowflake_term(sf);
        fail_msg("MFA environment variables not set - SNOWFLAKE_AUTH_TEST_MFA_USER and SNOWFLAKE_AUTH_TEST_MFA_PASSWORD required");
        return;
    }
    
    snowflake_set_attribute(sf, SF_CON_USER, mfa_user);
    snowflake_set_attribute(sf, SF_CON_PASSWORD, mfa_password);
    snowflake_set_attribute(sf, SF_CON_CLIENT_REQUEST_MFA_TOKEN, &(sf_bool){1});
          
    char** totpCodes = getTotpCodes("");
    
    if (!totpCodes) {
        snowflake_term(sf);
        fail_msg("No TOTP codes were generated by getTotpCodes() - test cannot proceed");
        return;
    }
    
    char lastError[1024] = {0};
    
    for (int i = 0; i < 3 && totpCodes[i]; i++) {
        printf("Trying TOTP code %d: %s\n", i + 1, totpCodes[i]);
        
        snowflake_set_attribute(sf, SF_CON_PASSCODE, totpCodes[i]);
        
        SF_STATUS status = snowflake_connect(sf);
        
        if (status == SF_STATUS_SUCCESS) {
            printf("MFA authentication successful with TOTP code %d\n", i + 1);
            
            // Check if MFA token was saved during first connection
            secure_storage_ptr ss_check = secure_storage_init();
            char* saved_token = secure_storage_get_credential(ss_check, sf->host, mfa_user, MFA_TOKEN);
            if (saved_token) {
                printf("DEBUG: MFA token saved successfully (length: %zu)\n", strlen(saved_token));
                secure_storage_free_credential(saved_token);
            } else {
                printf("DEBUG: WARNING - No MFA token found in cache after successful TOTP auth!\n");
            }
            secure_storage_term(ss_check);
            
            snowflake_term(sf);
            
            sf = snowflake_init();
            set_all_snowflake_attributes(sf);
            snowflake_set_attribute(sf, SF_CON_USER, mfa_user);
            snowflake_set_attribute(sf, SF_CON_PASSWORD, mfa_password);
            snowflake_set_attribute(sf, SF_CON_CLIENT_REQUEST_MFA_TOKEN, &(sf_bool){1});
            snowflake_set_attribute(sf, SF_CON_PASSCODE, NULL); // No TOTP - rely on cached MFA token

            // Check if MFA token is available before second connection
            secure_storage_ptr ss_check2 = secure_storage_init();
            char* retrieved_token = secure_storage_get_credential(ss_check2, sf->host, mfa_user, MFA_TOKEN);
            if (retrieved_token) {
                printf("DEBUG: MFA token retrieved for cache test (length: %zu)\n", strlen(retrieved_token));
                secure_storage_free_credential(retrieved_token);
            } else {
                printf("DEBUG: ERROR - No MFA token available for cache test!\n");
            }
            secure_storage_term(ss_check2);

            printf("DEBUG: Testing MFA token caching (no TOTP) - should use cached mfaToken\n");
            SF_STATUS cacheStatus = snowflake_connect(sf);
            
            if (cacheStatus != SF_STATUS_SUCCESS) {
                SF_ERROR_STRUCT* error = snowflake_error(sf);
                printf("DEBUG: Cache test failed - Code: %d, Message: %s\n", 
                       error ? error->error_code : -1, error ? error->msg : "Unknown error");
            }
            
            freeTotpCodes(totpCodes);
            assert_int_equal(cacheStatus, SF_STATUS_SUCCESS);
            printf("SUCCESS: MFA authentication and token caching completed successfully\n");
            snowflake_term(sf);
            
            // Cleanup cache directory
            rmdir(cache_path);
            return;
        } else {
            SF_ERROR_STRUCT* error = snowflake_error(sf);
            const char* errorMsg = error ? error->msg : "Unknown error";
            snprintf(lastError, sizeof(lastError), "%s", errorMsg);
            
            printf("DEBUG: Full error details - Code: %d, Message: %s\n", 
                   error ? error->error_code : -1, errorMsg);

            if (strstr(errorMsg, "Invalid") || strstr(errorMsg, "TOTP") ||
                strstr(errorMsg, "passcode") || strstr(errorMsg, "MFA") ||
                strstr(errorMsg, "authentication failed")) {
                printf("WARN: TOTP attempt %d failed - retrying with next code\n", i + 1);

                snowflake_set_attribute(sf, SF_CON_USER, mfa_user);
                snowflake_set_attribute(sf, SF_CON_PASSWORD, mfa_password);
                snowflake_set_attribute(sf, SF_CON_CLIENT_REQUEST_MFA_TOKEN, &(sf_bool){1});
                
                continue;
            } else {
                printf("WARN: Non-TOTP error on attempt %d, stopping: %s\n", i + 1, lastError);
                break;
            }
        }
    }
    freeTotpCodes(totpCodes);
    snowflake_term(sf);
    
    // Cleanup cache directory on failure
    rmdir(cache_path);
    
    printf("ERROR: Failed to connect with any TOTP codes. Last error: %s\n", lastError);
    fail();
}
