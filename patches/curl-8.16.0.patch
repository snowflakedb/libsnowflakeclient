diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0265162e7..7b8b0b4b4 100644
--- a/deps/curl/CMakeLists.txt
+++ b/deps/curl/CMakeLists.txt
@@ -253,6 +253,7 @@ if(WIN32)
     endif()
     unset(MINGW64_VERSION CACHE)  # Avoid storing in CMake cache
   endif()
+  string(APPEND CMAKE_C_FLAGS " /Z7 /ZH:SHA_256 /guard:cf /Qspectre /sdl")
 elseif(DOS OR AMIGA)
   set(BUILD_SHARED_LIBS OFF)
   set(BUILD_STATIC_LIBS ON)
@@ -922,6 +923,9 @@ if(CURL_DEFAULT_SSL_BACKEND AND NOT _valid_default_ssl_backend)
   message(FATAL_ERROR "CURL_DEFAULT_SSL_BACKEND '${CURL_DEFAULT_SSL_BACKEND}' not enabled.")
 endif()
 
+if(WIN32)
+  list(APPEND CURL_LIBS ${OOB_LIBRARY})
+endif()
 # Keep ZLIB detection after TLS detection,
 # and before calling curl_openssl_check_exists().
 
@@ -1954,6 +1958,7 @@ include(CMake/OtherTests.cmake)
 set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS "HAVE_CONFIG_H")
 
 if(WIN32)
+  list(APPEND CURL_LIBS "crypt32" "ole32" "msvcrt")
   list(APPEND CURL_NETWORK_AND_TIME_LIBS "${_win32_winsock}")
   if(NOT WINCE AND NOT WINDOWS_STORE)
     list(APPEND CURL_NETWORK_AND_TIME_LIBS "iphlpapi")
diff --git a/include/curl/curl.h b/include/curl/curl.h
index 6f4aa90f1..940d45c9e 100644
--- a/deps/curl/include/curl/curl.h
+++ b/deps/curl/include/curl/curl.h
@@ -109,6 +109,9 @@ extern "C" {
 typedef void CURL;
 typedef void CURLSH;
 
+#ifdef __linux__
+extern char sf_enable_getaddrinfo_lock;
+#endif
 /*
  * libcurl external API function linkage decorations.
  */
@@ -2258,6 +2261,34 @@ typedef enum {
   /* set TLS supported signature algorithms */
   CURLOPT(CURLOPT_SSL_SIGNATURE_ALGORITHMS, CURLOPTTYPE_STRINGPOINT, 328),
 
+  /* Snowflake options. True if enabling ocsp check */
+  CURLOPT(CURLOPT_SSL_SF_OCSP_CHECK, CURLOPTTYPE_LONG, 329),
+
+  /* Snowflake options. True if soft fail is enabled */
+  CURLOPT(CURLOPT_SSL_SF_OCSP_FAIL_OPEN, CURLOPTTYPE_LONG, 330),
+
+  /* Snowflake options. True if OOB telemetry is enabled. Defaults to false */
+  CURLOPT(CURLOPT_SSL_SF_OOB_ENABLE, CURLOPTTYPE_LONG, 331),
+
+  /* Snowflake options. True if CRL checking is enabled. Defaults to false */
+  CURLOPT(CURLOPT_SSL_SF_CRL_CHECK, CURLOPTTYPE_LONG, 332),
+
+  /* Snowflake options. True if CRL should be in advisory mode.
+   * Defaults to true */
+  CURLOPT(CURLOPT_SSL_SF_CRL_ADVISORY, CURLOPTTYPE_LONG, 333),
+
+  /* Snowflake options. True if CRL checking allows no CRL. Defaults to true */
+  CURLOPT(CURLOPT_SSL_SF_CRL_ALLOW_NO_CRL, CURLOPTTYPE_LONG, 334),
+
+  /* Snowflake options. True if CRL is cached on disk. Defaults to true */
+  CURLOPT(CURLOPT_SSL_SF_CRL_DISK_CACHING, CURLOPTTYPE_LONG, 335),
+
+  /* Snowflake options. True if CRL is cached in memory. Defaults to true */
+  CURLOPT(CURLOPT_SSL_SF_CRL_MEMORY_CACHING, CURLOPTTYPE_LONG, 336),
+
+  /* Snowflake options. CRL download timeout */
+  CURLOPT(CURLOPT_SSL_SF_CRL_DOWNLOAD_TIMEOUT, CURLOPTTYPE_LONG, 337),
+
   CURLOPT_LASTENTRY /* the last unused */
 } CURLoption;
 
diff --git a/deps/curl/include/curl/curlver.h b/deps/curl/include/curl/curlver.h
index 48fb81df8..3c7a91941 100644
--- a/include/curl/curlver.h
+++ b/include/curl/curlver.h
@@ -32,7 +32,7 @@
 
 /* This is the version number of the libcurl package from which this header
    file origins: */
-#define LIBCURL_VERSION "8.16.0-DEV"
+#define LIBCURL_VERSION "8.16.0"
 
 /* The numeric version number is also available "in parts" by using these
    defines: */
@@ -69,7 +69,7 @@
  *
  * "2007-11-23"
  */
-#define LIBCURL_TIMESTAMP "[unreleased]"
+#define LIBCURL_TIMESTAMP "2025-09-10"
 
 #define CURL_VERSION_BITS(x,y,z) ((x)<<16|(y)<<8|(z))
 #define CURL_AT_LEAST_VERSION(x,y,z) \
diff --git a/deps/curl/lib/CMakeLists.txt b/deps/curl/lib/CMakeLists.txt
index 3476d55b0..1586dbec7 100644
--- a/deps/curl/lib/CMakeLists.txt
+++ b/deps/curl/lib/CMakeLists.txt
@@ -141,6 +141,7 @@ if(BUILD_STATIC_LIBS)
   add_library(${PROJECT_NAME}::${LIB_STATIC} ALIAS ${LIB_STATIC})
   if(WIN32)
     set_property(TARGET ${LIB_STATIC} APPEND PROPERTY COMPILE_DEFINITIONS "CURL_STATICLIB")
+	list(APPEND CURL_LIBS "ws2_32.lib" "crypt32.lib" "msvcrt.lib")
   endif()
   target_link_libraries(${LIB_STATIC} PRIVATE ${CURL_LIBS})
   # Remove the "lib" prefix since the library is already named "libcurl".
@@ -166,6 +167,13 @@ if(BUILD_STATIC_LIBS)
   target_include_directories(${LIB_STATIC} INTERFACE
     "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
     "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>")
+  if(WIN32)
+    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
+      set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} crypt32.lib ws2_32.lib msvcrt.lib ole32.lib")
+    else()
+      set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} crypt32.lib ws2_32.lib ole32.lib")
+    endif()
+  endif()
 endif()
 
 if(BUILD_SHARED_LIBS)
diff --git a/deps/curl/lib/Makefile.in b/deps/curl/lib/Makefile.in
index a7f8065d96..3e3602dead 100644
--- a/deps/curl/lib/Makefile.in
+++ b/deps/curl/lib/Makefile.in
@@ -366,7 +366,8 @@ am__objects_3 = vtls/libcurl_la-cipher_suite.lo \
 	vtls/libcurl_la-schannel.lo vtls/libcurl_la-schannel_verify.lo \
 	vtls/libcurl_la-vtls.lo vtls/libcurl_la-vtls_scache.lo \
 	vtls/libcurl_la-vtls_spack.lo vtls/libcurl_la-wolfssl.lo \
-	vtls/libcurl_la-x509asn1.lo
+	vtls/libcurl_la-x509asn1.lo vtls/libcurl_la-sf_ocsp.lo \
+	vtls/libcurl_la-sf_crl.lo vtls/libcurl_la-sf_cJSON.lo
 am__objects_4 = vquic/libcurl_la-curl_ngtcp2.lo \
 	vquic/libcurl_la-curl_osslq.lo vquic/libcurl_la-curl_quiche.lo \
 	vquic/libcurl_la-vquic.lo vquic/libcurl_la-vquic-tls.lo
@@ -480,7 +481,9 @@ am__libcurlu_la_SOURCES_DIST = altsvc.c amigaos.c asyn-ares.c \
 	curlx/dynbuf.h curlx/inet_ntop.h curlx/inet_pton.h \
 	curlx/multibyte.h curlx/nonblock.h curlx/strparse.h \
 	curlx/timediff.h curlx/timeval.h curlx/version_win32.h \
-	curlx/wait.h curlx/warnless.h curlx/winapi.h
+	curlx/wait.h curlx/warnless.h curlx/winapi.h \
+	vtls/libcurl_la-sf_ocsp.lo vtls/libcurl_la-sf_crl.lo \
+	vtls/libcurl_la-sf_cJSON.lo
 am__objects_13 = libcurlu_la-altsvc.lo libcurlu_la-amigaos.lo \
 	libcurlu_la-asyn-ares.lo libcurlu_la-asyn-base.lo \
 	libcurlu_la-asyn-thrdd.lo libcurlu_la-bufq.lo \
@@ -539,7 +542,9 @@ am__objects_13 = libcurlu_la-altsvc.lo libcurlu_la-amigaos.lo \
 	libcurlu_la-transfer.lo libcurlu_la-uint-bset.lo \
 	libcurlu_la-uint-hash.lo libcurlu_la-uint-spbset.lo \
 	libcurlu_la-uint-table.lo libcurlu_la-url.lo \
-	libcurlu_la-urlapi.lo libcurlu_la-version.lo libcurlu_la-ws.lo
+	libcurlu_la-urlapi.lo libcurlu_la-version.lo libcurlu_la-ws.lo \
+	vtls/libcurl_la-sf_ocsp.lo vtls/libcurl_la-sf_crl.lo \
+	vtls/libcurl_la-sf_cJSON.lo
 am__objects_14 = vauth/libcurlu_la-cleartext.lo \
 	vauth/libcurlu_la-cram.lo vauth/libcurlu_la-digest.lo \
 	vauth/libcurlu_la-digest_sspi.lo vauth/libcurlu_la-gsasl.lo \
@@ -937,6 +942,9 @@ am__depfiles_remade = ./$(DEPDIR)/libcurl_la-altsvc.Plo \
 	vtls/$(DEPDIR)/libcurl_la-rustls.Plo \
 	vtls/$(DEPDIR)/libcurl_la-schannel.Plo \
 	vtls/$(DEPDIR)/libcurl_la-schannel_verify.Plo \
+	vtls/$(DEPDIR)/libcurl_la-sf_cJSON.Plo \
+	vtls/$(DEPDIR)/libcurl_la-sf_ocsp.Plo \
+	vtls/$(DEPDIR)/libcurl_la-sf_crl.Plo \
 	vtls/$(DEPDIR)/libcurl_la-vtls.Plo \
 	vtls/$(DEPDIR)/libcurl_la-vtls_scache.Plo \
 	vtls/$(DEPDIR)/libcurl_la-vtls_spack.Plo \
@@ -952,6 +960,9 @@ am__depfiles_remade = ./$(DEPDIR)/libcurl_la-altsvc.Plo \
 	vtls/$(DEPDIR)/libcurlu_la-rustls.Plo \
 	vtls/$(DEPDIR)/libcurlu_la-schannel.Plo \
 	vtls/$(DEPDIR)/libcurlu_la-schannel_verify.Plo \
+	vtls/$(DEPDIR)/libcurlu_la-sf_cJSON.Plo \
+	vtls/$(DEPDIR)/libcurlu_la-sf_ocsp.Plo \
+	vtls/$(DEPDIR)/libcurlu_la-sf_crl.Plo \
 	vtls/$(DEPDIR)/libcurlu_la-vtls.Plo \
 	vtls/$(DEPDIR)/libcurlu_la-vtls_scache.Plo \
 	vtls/$(DEPDIR)/libcurlu_la-vtls_spack.Plo \
@@ -1266,7 +1277,10 @@ LIB_VTLS_CFILES = \
   vtls/vtls_scache.c        \
   vtls/vtls_spack.c         \
   vtls/wolfssl.c            \
-  vtls/x509asn1.c
+  vtls/x509asn1.c           \
+  vtls/sf_ocsp.c            \
+  vtls/sf_crl.c             \
+  vtls/sf_cJSON.c
 
 LIB_VTLS_HFILES = \
   vtls/cipher_suite.h       \
@@ -1284,7 +1298,10 @@ LIB_VTLS_HFILES = \
   vtls/vtls_scache.h        \
   vtls/vtls_spack.h         \
   vtls/wolfssl.h            \
-  vtls/x509asn1.h
+  vtls/x509asn1.h           \
+  vtls/sf_ocsp.h            \
+  vtls/sf_crl.h             \
+  vtls/sf_cJSON.h
 
 LIB_VQUIC_CFILES = \
   vquic/curl_ngtcp2.c   \
@@ -1593,7 +1610,7 @@ EXTRA_DIST = config-mac.h config-os400.h config-plan9.h config-riscos.h \
   $(CMAKE_DIST) Makefile.soname optiontable.pl $(CHECKSRC_DIST)
 
 lib_LTLIBRARIES = libcurl.la
-@BUILD_UNITTESTS_FALSE@noinst_LTLIBRARIES = 
+@BUILD_UNITTESTS_FALSE@noinst_LTLIBRARIES =
 @BUILD_UNITTESTS_TRUE@noinst_LTLIBRARIES = libcurlu.la
 
 # generate a file with "private" prototypes for unit testing
@@ -1609,15 +1626,15 @@ lib_LTLIBRARIES = libcurl.la
 # $(srcdir) for the generated unity source to find included sources
 AM_CPPFLAGS = -I$(top_srcdir)/include -I$(top_builddir)/lib \
 	-I$(srcdir) $(am__append_1) $(am__append_2) -DBUILDING_LIBCURL
-AM_LDFLAGS = 
-AM_CFLAGS = 
+AM_LDFLAGS =
+AM_CFLAGS =
 @USE_UNITY_TRUE@nodist_libcurl_la_SOURCES = libcurl_unity.c
 @USE_UNITY_FALSE@libcurl_la_SOURCES = $(CSOURCES) $(HHEADERS) \
 @USE_UNITY_FALSE@	$(am__append_10)
 @USE_UNITY_TRUE@libcurl_la_SOURCES = $(am__append_10)
 @USE_UNITY_TRUE@nodist_libcurlu_la_SOURCES = libcurl_unity.c
 @USE_UNITY_FALSE@libcurlu_la_SOURCES = $(CSOURCES) $(HHEADERS)
-@USE_UNITY_TRUE@libcurlu_la_SOURCES = 
+@USE_UNITY_TRUE@libcurlu_la_SOURCES =
 @USE_UNITY_FALSE@CLEANFILES = $(UNITPROTOS)
 @USE_UNITY_TRUE@CLEANFILES = libcurl_unity.c $(UNITPROTOS)
 libcurl_la_CPPFLAGS_EXTRA = $(am__append_9) $(am__append_11)
@@ -1647,7 +1664,7 @@ CS_ = $(CS_0)
 @DEBUGBUILD_TRUE@@NOT_CURL_CI_TRUE@CHECKSOURCES = checksrc
 UNIT_V = $(UNITV_$(V))
 UNITV_0 = @echo "  UNITPR  " $@;
-UNITV_1 = 
+UNITV_1 =
 UNITV_ = $(UNITV_0)
 
 # disable the tests that are mostly causing false positives
@@ -1820,6 +1837,12 @@ vtls/libcurl_la-wolfssl.lo: vtls/$(am__dirstamp) \
 	vtls/$(DEPDIR)/$(am__dirstamp)
 vtls/libcurl_la-x509asn1.lo: vtls/$(am__dirstamp) \
 	vtls/$(DEPDIR)/$(am__dirstamp)
+vtls/libcurl_la-sf_ocsp.lo: vtls/$(am__dirstamp) \
+	vtls/$(DEPDIR)/$(am__dirstamp)
+vtls/libcurl_la-sf_crl.lo: vtls/$(am__dirstamp) \
+	vtls/$(DEPDIR)/$(am__dirstamp)
+vtls/libcurl_la-sf_cJSON.lo: vtls/$(am__dirstamp) \
+	vtls/$(DEPDIR)/$(am__dirstamp)
 vquic/$(am__dirstamp):
 	@$(MKDIR_P) vquic
 	@: > vquic/$(am__dirstamp)
@@ -1941,6 +1964,12 @@ vtls/libcurlu_la-wolfssl.lo: vtls/$(am__dirstamp) \
 	vtls/$(DEPDIR)/$(am__dirstamp)
 vtls/libcurlu_la-x509asn1.lo: vtls/$(am__dirstamp) \
 	vtls/$(DEPDIR)/$(am__dirstamp)
+vtls/libcurlu_la-sf_ocsp.lo: vtls/$(am__dirstamp) \
+	vtls/$(DEPDIR)/$(am__dirstamp)
+vtls/libcurlu_la-sf_crl.lo: vtls/$(am__dirstamp) \
+	vtls/$(DEPDIR)/$(am__dirstamp)
+vtls/libcurlu_la-sf_cJSON.lo: vtls/$(am__dirstamp) \
+	vtls/$(DEPDIR)/$(am__dirstamp)
 vquic/libcurlu_la-curl_ngtcp2.lo: vquic/$(am__dirstamp) \
 	vquic/$(DEPDIR)/$(am__dirstamp)
 vquic/libcurlu_la-curl_osslq.lo: vquic/$(am__dirstamp) \
@@ -2342,6 +2371,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-mbedtls.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-mbedtls_threadlock.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-openssl.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-sf_ocsp.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-sf_crl.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-sf_cJSON.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-rustls.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-schannel.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurl_la-schannel_verify.Plo@am__quote@ # am--include-marker
@@ -2357,6 +2389,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-mbedtls.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-mbedtls_threadlock.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-openssl.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-sf_ocsp.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-sf_crl.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-sf_cJSON.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-rustls.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-schannel.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@vtls/$(DEPDIR)/libcurlu_la-schannel_verify.Plo@am__quote@ # am--include-marker
@@ -3488,6 +3523,27 @@ vtls/libcurl_la-x509asn1.lo: vtls/x509asn1.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurl_la-x509asn1.lo `test -f 'vtls/x509asn1.c' || echo '$(srcdir)/'`vtls/x509asn1.c
 
+vtls/libcurl_la-sf_ocsp.lo: vtls/sf_ocsp.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -MT vtls/libcurl_la-sf_ocsp.lo -MD -MP -MF vtls/$(DEPDIR)/libcurl_la-sf_ocsp.Tpo -c -o vtls/libcurl_la-sf_ocsp.lo `test -f 'vtls/sf_ocsp.c' || echo '$(srcdir)/'`vtls/sf_ocsp.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vtls/$(DEPDIR)/libcurl_la-sf_ocsp.Tpo vtls/$(DEPDIR)/libcurl_la-sf_ocsp.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='vtls/sf_ocsp.c' object='vtls/libcurl_la-sf_ocsp.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurl_la-sf_ocsp.lo `test -f 'vtls/sf_ocsp.c' || echo '$(srcdir)/'`vtls/sf_ocsp.c
+
+vtls/libcurl_la-sf_crl.lo: vtls/sf_crl.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -MT vtls/libcurl_la-sf_crl.lo -MD -MP -MF vtls/$(DEPDIR)/libcurl_la-sf_crl.Tpo -c -o vtls/libcurl_la-sf_crl.lo `test -f 'vtls/sf_crl.c' || echo '$(srcdir)/'`vtls/sf_crl.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vtls/$(DEPDIR)/libcurl_la-sf_crl.Tpo vtls/$(DEPDIR)/libcurl_la-sf_crl.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='vtls/sf_crl.c' object='vtls/libcurl_la-sf_crl.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurl_la-sf_crl.lo `test -f 'vtls/sf_crl.c' || echo '$(srcdir)/'`vtls/sf_crl.c
+
+vtls/libcurl_la-sf_cJSON.lo: vtls/sf_cJSON.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -MT vtls/libcurl_la-sf_cJSON.lo -MD -MP -MF vtls/$(DEPDIR)/libcurl_la-sf_cJSON.Tpo -c -o vtls/libcurl_la-sf_cJSON.lo `test -f 'vtls/sf_cJSON.c' || echo '$(srcdir)/'`vtls/sf_cJSON.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vtls/$(DEPDIR)/libcurl_la-sf_cJSON.Tpo vtls/$(DEPDIR)/libcurl_la-sf_cJSON.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='vtls/sf_cJSON.c' object='vtls/libcurl_la-sf_cJSON.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurl_la-sf_cJSON.lo `test -f 'vtls/sf_cJSON.c' || echo '$(srcdir)/'`vtls/sf_cJSON.c
+
 vquic/libcurl_la-curl_ngtcp2.lo: vquic/curl_ngtcp2.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurl_la_CPPFLAGS) $(CPPFLAGS) $(libcurl_la_CFLAGS) $(CFLAGS) -MT vquic/libcurl_la-curl_ngtcp2.lo -MD -MP -MF vquic/$(DEPDIR)/libcurl_la-curl_ngtcp2.Tpo -c -o vquic/libcurl_la-curl_ngtcp2.lo `test -f 'vquic/curl_ngtcp2.c' || echo '$(srcdir)/'`vquic/curl_ngtcp2.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vquic/$(DEPDIR)/libcurl_la-curl_ngtcp2.Tpo vquic/$(DEPDIR)/libcurl_la-curl_ngtcp2.Plo
@@ -4748,6 +4804,27 @@ vtls/libcurlu_la-x509asn1.lo: vtls/x509asn1.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurlu_la-x509asn1.lo `test -f 'vtls/x509asn1.c' || echo '$(srcdir)/'`vtls/x509asn1.c
 
+vtls/libcurlu_la-sf_ocsp.lo: vtls/sf_ocsp.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -MT vtls/libcurlu_la-sf_ocsp.lo -MD -MP -MF vtls/$(DEPDIR)/libcurlu_la-sf_ocsp.Tpo -c -o vtls/libcurlu_la-sf_ocsp.lo `test -f 'vtls/sf_ocsp.c' || echo '$(srcdir)/'`vtls/sf_ocsp.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vtls/$(DEPDIR)/libcurlu_la-sf_ocsp.Tpo vtls/$(DEPDIR)/libcurlu_la-sf_ocsp.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='vtls/sf_ocsp.c' object='vtls/libcurlu_la-sf_ocsp.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurlu_la-sf_ocsp.lo `test -f 'vtls/sf_ocsp.c' || echo '$(srcdir)/'`vtls/sf_ocsp.c
+
+vtls/libcurlu_la-sf_crl.lo: vtls/sf_crl.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -MT vtls/libcurlu_la-sf_crl.lo -MD -MP -MF vtls/$(DEPDIR)/libcurlu_la-sf_crl.Tpo -c -o vtls/libcurlu_la-sf_crl.lo `test -f 'vtls/sf_crl.c' || echo '$(srcdir)/'`vtls/sf_crl.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vtls/$(DEPDIR)/libcurlu_la-sf_crl.Tpo vtls/$(DEPDIR)/libcurlu_la-sf_crl.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='vtls/sf_crl.c' object='vtls/libcurlu_la-sf_crl.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurlu_la-sf_crl.lo `test -f 'vtls/sf_crl.c' || echo '$(srcdir)/'`vtls/sf_crl.c
+
+vtls/libcurlu_la-sf_cJSON.lo: vtls/sf_cJSON.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -MT vtls/libcurlu_la-sf_cJSON.lo -MD -MP -MF vtls/$(DEPDIR)/libcurlu_la-sf_cJSON.Tpo -c -o vtls/libcurlu_la-sf_cJSON.lo `test -f 'vtls/sf_cJSON.c' || echo '$(srcdir)/'`vtls/sf_cJSON.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vtls/$(DEPDIR)/libcurlu_la-sf_cJSON.Tpo vtls/$(DEPDIR)/libcurlu_la-sf_cJSON.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='vtls/sf_cJSON.c' object='vtls/libcurlu_la-sf_cJSON.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -c -o vtls/libcurlu_la-sf_cJSON.lo `test -f 'vtls/sf_cJSON.c' || echo '$(srcdir)/'`vtls/sf_cJSON.c
+
 vquic/libcurlu_la-curl_ngtcp2.lo: vquic/curl_ngtcp2.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcurlu_la_CPPFLAGS) $(CPPFLAGS) $(libcurlu_la_CFLAGS) $(CFLAGS) -MT vquic/libcurlu_la-curl_ngtcp2.lo -MD -MP -MF vquic/$(DEPDIR)/libcurlu_la-curl_ngtcp2.Tpo -c -o vquic/libcurlu_la-curl_ngtcp2.lo `test -f 'vquic/curl_ngtcp2.c' || echo '$(srcdir)/'`vquic/curl_ngtcp2.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) vquic/$(DEPDIR)/libcurlu_la-curl_ngtcp2.Tpo vquic/$(DEPDIR)/libcurlu_la-curl_ngtcp2.Plo
@@ -5887,7 +5964,8 @@ uninstall-am: uninstall-libLTLIBRARIES
 
 checksrc:
 	$(CHECKSRC)(@PERL@ $(top_srcdir)/scripts/checksrc.pl -D$(srcdir) \
-	$(CSOURCES) $(HHEADERS))
+	-Wvtls/sf_cJSON.c -Wvtls/sf_cJSON.h -Wvtls/sf_ocsp.c -Wvtls/sf_ocsp.h \
+	-Wvtls/sf_crl.c -Wvtls/sf_crl.h $(CSOURCES) $(HHEADERS))
 
 all-local: $(CHECKSOURCES)
diff --git a/deps/curl/lib/Makefile.inc b/deps/curl/lib/Makefile.inc
index 524fdcc53..7bea95e8f 100644
--- a/deps/curl/lib/Makefile.inc
+++ b/deps/curl/lib/Makefile.inc
@@ -89,7 +89,10 @@ LIB_VTLS_CFILES =           \
   vtls/vtls_scache.c        \
   vtls/vtls_spack.c         \
   vtls/wolfssl.c            \
-  vtls/x509asn1.c
+  vtls/x509asn1.c           \
+  vtls/sf_ocsp.c            \
+  vtls/sf_crl.c             \
+  vtls/sf_cJSON.c
 
 LIB_VTLS_HFILES =           \
   vtls/cipher_suite.h       \
@@ -107,7 +110,10 @@ LIB_VTLS_HFILES =           \
   vtls/vtls_scache.h        \
   vtls/vtls_spack.h         \
   vtls/wolfssl.h            \
-  vtls/x509asn1.h
+  vtls/x509asn1.h           \
+  vtls/sf_ocsp.h            \
+  vtls/sf_crl.h             \
+  vtls/sf_cJSON.h
 
 LIB_VQUIC_CFILES = \
   vquic/curl_ngtcp2.c   \
diff --git a/deps/curl/lib/curl_addrinfo.c b/deps/curl/lib/curl_addrinfo.c
index 22212ac86..e1cf99a93 100644
--- a/lib/curl_addrinfo.c
+++ b/lib/curl_addrinfo.c
@@ -47,6 +47,10 @@
 #  include <inet.h>
 #endif
 
+#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)
+#include <pthread.h>
+#endif
+
 #include <stddef.h>
 
 #include "curl_addrinfo.h"
@@ -87,6 +91,15 @@ Curl_freeaddrinfo(struct Curl_addrinfo *cahead)
   }
 }
 
+#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)
+static void Curl_print_pthread_error(int error)
+{
+  printf("pthread mutex_raw error no is: %d\n", error);
+  if(error == SOCKEINVAL) {
+    printf("the mutex has not been properly initialized.\n");
+  }
+}
+#endif
 
 #ifdef HAVE_GETADDRINFO
 /*
@@ -103,6 +116,16 @@ Curl_freeaddrinfo(struct Curl_addrinfo *cahead)
  * whole library, any such call should be 'routed' through this one.
  */
 
+ /*
+ * SNOW-119090 where application is not pthread compatible causing
+ * libnss_file.so being loaded before the pthread and SEGFAULT when
+ * calling getaddrinfo().
+ */
+#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)
+static pthread_mutex_t sf_getaddrinfo_mutex = PTHREAD_MUTEX_INITIALIZER;
+char sf_enable_getaddrinfo_lock = 0;
+#endif
+
 int
 Curl_getaddrinfo_ex(const char *nodename,
                     const char *servname,
@@ -116,9 +139,22 @@ Curl_getaddrinfo_ex(const char *nodename,
   struct Curl_addrinfo *ca;
   size_t ss_size;
   int error;
+#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)
+  int mutex_error;
+#endif
 
   *result = NULL; /* assume failure */
 
+#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)
+  if(sf_enable_getaddrinfo_lock == 1) {
+    mutex_error = pthread_mutex_lock(&sf_getaddrinfo_mutex);
+    if(mutex_error) {
+      Curl_print_pthread_error(mutex_error);
+      return mutex_error;
+    }
+  }
+#endif
+
   error = CURL_GETADDRINFO(nodename, servname, hints, &aihead);
   if(error)
     return error;
@@ -187,6 +223,16 @@ Curl_getaddrinfo_ex(const char *nodename,
   if(aihead)
     CURL_FREEADDRINFO(aihead);
 
+#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)
+  if(sf_enable_getaddrinfo_lock == 1) {
+    mutex_error = pthread_mutex_unlock(&sf_getaddrinfo_mutex);
+    if(mutex_error) {
+      Curl_print_pthread_error(mutex_error);
+      error = mutex_error;
+    }
+  }
+#endif
+
   /* if we failed, also destroy the Curl_addrinfo list */
   if(error) {
     Curl_freeaddrinfo(cafirst);
diff --git a/deps/curl/lib/setopt.c b/deps/curl/lib/setopt.c
index 5adfe4dbe..cc2bdba31 100644
--- a/deps/curl/lib/setopt.c
+++ b/deps/curl/lib/setopt.c
@@ -1282,6 +1282,51 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
   case CURLOPT_UPLOAD_FLAGS:
     s->upload_flags = (unsigned char)arg;
     break;
+  case CURLOPT_SSL_SF_OCSP_CHECK:
+    data->set.ssl.primary.sf_ocsp_check = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_OCSP_FAIL_OPEN:
+    data->set.ssl.primary.sf_ocsp_failopen = (0 != arg) ?
+                                         TRUE:FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_OOB_ENABLE:
+    data->set.ssl.primary.sf_oob_enable = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_CRL_CHECK:
+    data->set.ssl.primary.sf_crl_check = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_CRL_ADVISORY:
+    data->set.ssl.primary.sf_crl_advisory = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_CRL_ALLOW_NO_CRL:
+    data->set.ssl.primary.sf_crl_allow_no_crl = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_CRL_DISK_CACHING:
+    data->set.ssl.primary.sf_crl_disk_caching = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_CRL_MEMORY_CACHING:
+    data->set.ssl.primary.sf_crl_memory_caching = (0 != arg) ?
+                                         TRUE : FALSE;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
+  case CURLOPT_SSL_SF_CRL_DOWNLOAD_TIMEOUT:
+      data->set.ssl.primary.sf_crl_download_timeout = (arg != 0) ?
+                                         (unsigned int)arg : 120;
+    Curl_ssl_conn_config_update(data, FALSE);
+    break;
   default:
     return CURLE_UNKNOWN_OPTION;
   }
diff --git a/lib/url.c b/lib/url.c
index b52267cb6..5b6a08528 100644
--- a/deps/curl/lib/url.c
+++ b/deps/curl/lib/url.c
@@ -1443,6 +1443,36 @@ static struct connectdata *allocate_conn(struct Curl_easy *data)
   conn->connect_only = data->set.connect_only;
   conn->transport_wanted = TRNSPRT_TCP; /* most of them are TCP streams */
 
+  conn->ssl_config.sf_ocsp_check = data->set.ssl.primary.sf_ocsp_check;
+  conn->ssl_config.sf_ocsp_failopen = data->set.ssl.primary.sf_ocsp_failopen;
+  conn->ssl_config.sf_crl_check = data->set.ssl.primary.sf_crl_check;
+  conn->ssl_config.sf_crl_advisory = data->set.ssl.primary.sf_crl_advisory;
+  conn->ssl_config.sf_crl_allow_no_crl =
+    data->set.ssl.primary.sf_crl_allow_no_crl;
+  conn->ssl_config.sf_crl_disk_caching =
+    data->set.ssl.primary.sf_crl_disk_caching;
+  conn->ssl_config.sf_crl_memory_caching =
+    data->set.ssl.primary.sf_crl_memory_caching;
+  conn->ssl_config.sf_oob_enable = data->set.ssl.primary.sf_oob_enable;
+#ifndef CURL_DISABLE_PROXY
+  conn->proxy_ssl_config.sf_ocsp_check =
+    data->set.proxy_ssl.primary.sf_ocsp_check;
+  conn->proxy_ssl_config.sf_ocsp_failopen =
+    data->set.proxy_ssl.primary.sf_ocsp_failopen;
+  conn->proxy_ssl_config.sf_crl_check =
+    data->set.proxy_ssl.primary.sf_crl_check;
+  conn->proxy_ssl_config.sf_crl_advisory =
+    data->set.proxy_ssl.primary.sf_crl_advisory;
+  conn->proxy_ssl_config.sf_crl_allow_no_crl =
+    data->set.proxy_ssl.primary.sf_crl_allow_no_crl;
+  conn->proxy_ssl_config.sf_crl_disk_caching =
+    data->set.proxy_ssl.primary.sf_crl_disk_caching;
+  conn->proxy_ssl_config.sf_crl_memory_caching =
+    data->set.proxy_ssl.primary.sf_crl_memory_caching;
+  conn->proxy_ssl_config.sf_oob_enable =
+    data->set.proxy_ssl.primary.sf_oob_enable;
+#endif
+
   /* Initialize the attached xfers bitset */
   Curl_uint_spbset_init(&conn->xfers_attached);
 
diff --git a/deps/curl/lib/urldata.h b/deps/curl/lib/urldata.h
index cf181af64..e17fcb658 100644
--- a/deps/curl/lib/urldata.h
+++ b/deps/curl/lib/urldata.h
@@ -258,6 +258,17 @@ struct ssl_backend_data;
 struct Curl_ssl_scache_entry;
 
 struct ssl_primary_config {
+  bool sf_ocsp_check;    /* set TRUE if client side ocsp check is enabled */
+  bool sf_ocsp_failopen; /* set FALSE if failopen has to be disabled.*/
+  bool sf_crl_check;        /* set TRUE if client side CRL check is enabled */
+  bool sf_crl_advisory;     /* set TRUE if client side CRL check is
+                               in advisory mode */
+  bool sf_crl_allow_no_crl; /* set TRUE if client side CRL check allows
+                               certificates without crl */
+  bool sf_crl_disk_caching;   /* set FALSE to disable CRL disk caching */
+  bool sf_crl_memory_caching; /* set FALSE to disable CRL memory caching */
+  long sf_crl_download_timeout; /* timeout in seconds for CRL download */
+  bool sf_oob_enable;    /* set TRUE if OOB telemetry is enabled.*/
   char *CApath;          /* certificate dir (does not work on Windows) */
   char *CAfile;          /* certificate to verify peer against */
   char *issuercert;      /* optional issuer certificate filename */
diff --git a/deps/curl/lib/vtls/openssl.c b/deps/curl/lib/vtls/openssl.c
index a49203ab0..3ab701300 100644
--- a/deps/curl/lib/vtls/openssl.c
+++ b/deps/curl/lib/vtls/openssl.c
@@ -67,6 +67,8 @@
 #include "../strdup.h"
 #include "../strerror.h"
 #include "../curl_printf.h"
+#include "sf_ocsp.h"
+#include "sf_crl.h"
 
 #include <openssl/ssl.h>
 #include <openssl/rand.h>
@@ -154,6 +156,14 @@ static void ossl_provider_cleanup(struct Curl_easy *data);
 #define HAVE_OPAQUE_RSA_DSA_DH 1 /* since 1.1.0 -pre5 */
 #define HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED 1
 #else
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && \
+    !(defined(LIBRESSL_VERSION_NUMBER) && \
+      LIBRESSL_VERSION_NUMBER < 0x3060000fL) && \
+    !defined(OPENSSL_IS_BORINGSSL) && \
+    !defined(OPENSSL_IS_AWSLC)
+#define CURL_HAS_VERIFIED_CHAIN 1
+#endif
+
 /* For OpenSSL before 1.1.0 */
 #define ASN1_STRING_get0_data(x) ASN1_STRING_data(x)
 #define X509_get0_notBefore(x) X509_get_notBefore(x)
@@ -1890,6 +1900,12 @@ static int ossl_init(void)
 
   Curl_tls_keylog_open();
 
+  /* init Cert OCSP revocation checks */
+  initCertOCSP();
+
+  /* init Cert CRL revocation checks */
+  initCertCRL();
+
   return 1;
 }
 
@@ -3617,6 +3633,18 @@ CURLcode Curl_ssl_setup_x509_store(struct Curl_cfilter *cf,
   cached_store = ossl_get_cached_x509_store(cf, data);
   if(cached_store && cache_criteria_met && X509_STORE_up_ref(cached_store)) {
     SSL_CTX_set_cert_store(ssl_ctx, cached_store);
+
+    /* !!! Starting Snowflake CRL !!! */
+    /* Update CRL configuration even for cached store */
+    if(conn_config->sf_crl_check) {
+      registerCRLCheck(data, cached_store,
+                       conn_config->sf_crl_advisory,
+                       conn_config->sf_crl_allow_no_crl,
+                       conn_config->sf_crl_disk_caching,
+                       conn_config->sf_crl_memory_caching,
+                       conn_config->sf_crl_download_timeout);
+    }
+    /* !!! End of Snowflake CRL !!! */
   }
   else {
     X509_STORE *store = SSL_CTX_get_cert_store(ssl_ctx);
@@ -3625,6 +3653,17 @@ CURLcode Curl_ssl_setup_x509_store(struct Curl_cfilter *cf,
     if(result == CURLE_OK && cache_criteria_met) {
       ossl_set_cached_x509_store(cf, data, store);
     }
+
+    /* !!! Starting Snowflake CRL !!! */
+    if(conn_config->sf_crl_check) {
+      registerCRLCheck(data, store,
+                       conn_config->sf_crl_advisory,
+                       conn_config->sf_crl_allow_no_crl,
+                       conn_config->sf_crl_disk_caching,
+                       conn_config->sf_crl_memory_caching,
+                       conn_config->sf_crl_download_timeout);
+    }
+    /* !!! End of Snowflake CRL !!! */
   }
 
   ERR_pop_to_mark();
@@ -4754,9 +4793,7 @@ static CURLcode ossl_pkp_pin_peer_pubkey(struct Curl_easy *data, X509* cert,
   return result;
 }
 
-#if OPENSSL_VERSION_NUMBER >= 0x10100000L &&  \
-  !(defined(LIBRESSL_VERSION_NUMBER) && \
-    LIBRESSL_VERSION_NUMBER < 0x3060000fL) && \
+#if defined(CURL_HAS_VERIFIED_CHAIN) && \
   !defined(HAVE_BORINGSSL_LIKE) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
 static void infof_certstack(struct Curl_easy *data, const SSL *ssl)
 {
@@ -4867,6 +4904,54 @@ CURLcode Curl_ossl_check_peer_cert(struct Curl_cfilter *cf,
     return CURLE_PEER_FAILED_VERIFICATION;
   }
 
+  /* !!! Starting OCSP !!! */
+  if(conn_config->sf_ocsp_check) {
+    STACK_OF(X509) *ch = NULL;
+    X509_STORE     *st = NULL;
+
+    /* Prefer the verified chain if available to ensure correct issuer pairing
+       for cross-signed chains; fall back to peer-provided chain otherwise. */
+    infof(data, "OCSP: preferring verified chain for issuer determination");
+#if defined(CURL_HAS_VERIFIED_CHAIN)
+    {
+      STACK_OF(X509) *verified = SSL_get0_verified_chain(octx->ssl);
+      bool used_verified = false;
+      ch = verified;
+      if(!ch)
+        ch = SSL_get_peer_cert_chain(octx->ssl);
+      else
+        used_verified = true;
+      infof(data, "OCSP: used_verified_chain=%s",
+            used_verified ? "yes" : "no");
+    }
+#else
+    ch = SSL_get_peer_cert_chain(octx->ssl);
+#endif
+    if(!ch) {
+      infof(data, "OCSP validation could not get peer certificate chain");
+    }
+    st = SSL_CTX_get_cert_store(octx->ssl_ctx);
+    if(!st) {
+      infof(data, "OCSP validation could not get certificate data store");
+    }
+
+    /* Additional diagnostics for OCSP chain/store context */
+    infof(data, "OCSP: verified_chain_present=%s chain_count=%d",
+          ch ? "yes" : "no", ch ? sk_X509_num(ch) : 0);
+    infof(data, "OCSP: cert_store_present=%s", st ? "yes" : "no");
+
+    if(ch && st) {
+      result = checkCertOCSP(conn, data, ch, st,
+                             conn_config->sf_ocsp_failopen,
+                             conn_config->sf_oob_enable);
+      if(result) {
+        BIO_free(mem);
+        return result;
+      }
+    }
+  }
+  /* !!! End of OCSP !!! */
+
   infof(data, "%s certificate:",
         Curl_ssl_cf_is_proxy(cf) ? "Proxy" : "Server");
 
diff --git a/deps/curl/lib/vtls/sf_crl.c b/deps/curl/lib/vtls/sf_crl.c
new file mode 100644
index 000000000..bbfe69773
--- /dev/null
+++ b/deps/curl/lib/vtls/sf_crl.c
@@ -0,0 +1,831 @@
+#include "curl_setup.h"
+#include "urldata.h"
+#include "sendf.h"
+#include "sf_ocsp.h"
+#include "sf_crl.h"
+
+#include <stdbool.h>
+#include <openssl/x509v3.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+#ifdef _WIN32
+#define strcasecmp _stricmp
+#include <windows.h>
+typedef HANDLE SF_MUTEX_HANDLE;
+#ifndef PATH_MAX
+#define PATH_MAX MAX_PATH
+#endif
+#else
+typedef pthread_mutex_t SF_MUTEX_HANDLE;
+#endif
+
+static SF_MUTEX_HANDLE crl_response_cache_mutex;
+
+static int _mutex_init(SF_MUTEX_HANDLE *lock);
+static int _mutex_lock(SF_MUTEX_HANDLE *lock);
+static int _mutex_unlock(SF_MUTEX_HANDLE *lock);
+static int _mutex_term(SF_MUTEX_HANDLE *lock);
+
+
+/* Mutex */
+int _mutex_init(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  *lock = CreateMutex(
+	NULL,  // default security attribute
+	FALSE, // initially not owned
+	NULL   // unnamed mutext
+  );
+  return 0;
+#else
+  return pthread_mutex_init(lock, NULL);
+#endif
+}
+
+int _mutex_lock(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  DWORD ret = WaitForSingleObject(*lock, INFINITE);
+  return ret == WAIT_OBJECT_0 ? 0 : 1;
+#else
+  return pthread_mutex_lock(lock);
+#endif
+}
+
+int _mutex_unlock(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  return ReleaseMutex(*lock) == 0;
+#else
+  return pthread_mutex_unlock(lock);
+#endif
+}
+
+int _mutex_term(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  return CloseHandle(*lock) == 0;
+#else
+  return pthread_mutex_destroy(lock);
+#endif
+}
+
+/************************************************************************************
+ * Helpers to map X509_STORE* to configuration parameters 
+ ************************************************************************************/
+struct store_ctx_entry {
+  const X509_STORE *ctx;
+  struct Curl_easy *data;
+  int crl_advisory;
+  int crl_allow_no_crl;
+  int crl_disk_caching;
+  int crl_memory_caching;
+  int curr_crl_num;
+  long crl_download_timeout;  /* Timeout in seconds for CRL download */
+};
+
+struct store_ctx_array {
+  struct store_ctx_entry   *entries;
+  size_t                    size;     /* number of active entries */
+  size_t                    capacity; /* total allocated slots */
+};
+
+static struct store_ctx_array sctx_registry = {NULL, 0, 0};
+
+static int sctx_ensure_capacity()
+{
+  size_t new_capacity;
+  struct store_ctx_entry *new_entries;
+
+  if (sctx_registry.size >= sctx_registry.capacity) {
+    new_capacity = sctx_registry.capacity + 8;
+    new_entries = OPENSSL_realloc(sctx_registry.entries, new_capacity * sizeof(struct store_ctx_entry));
+    if (!new_entries)
+      return 0;
+    sctx_registry.entries = new_entries;
+    sctx_registry.capacity = new_capacity;
+  }
+  return 1;
+}
+
+static struct store_ctx_entry *sctx_lookup(const X509_STORE *ctx)
+{
+  for (size_t i = 0; i < sctx_registry.size; ++i) {
+    if (sctx_registry.entries[i].ctx == ctx)
+      return &sctx_registry.entries[i];
+  }
+  return NULL;
+}
+
+static void sctx_register(const X509_STORE *ctx, struct Curl_easy *data, bool crl_advisory,
+                          bool crl_allow_no_crl, bool crl_disk_caching, bool crl_memory_caching,
+                          long crl_download_timeout)
+{
+  struct store_ctx_entry *existing;
+
+  existing = sctx_lookup(ctx);
+  if (existing) {
+    existing->data = data;
+    existing->crl_advisory = crl_advisory;
+    existing->crl_allow_no_crl = crl_allow_no_crl;
+    existing->crl_disk_caching = crl_disk_caching;
+    existing->crl_memory_caching = crl_memory_caching;
+    existing->crl_download_timeout = crl_download_timeout;
+    return;
+  }
+  
+  if (!sctx_ensure_capacity())
+    return;
+  sctx_registry.entries[sctx_registry.size].ctx = ctx;
+  sctx_registry.entries[sctx_registry.size].data = data;
+  sctx_registry.entries[sctx_registry.size].crl_advisory = crl_advisory;
+  sctx_registry.entries[sctx_registry.size].crl_allow_no_crl = crl_allow_no_crl;
+  sctx_registry.entries[sctx_registry.size].crl_disk_caching = crl_disk_caching;
+  sctx_registry.entries[sctx_registry.size].crl_memory_caching = crl_memory_caching;
+  sctx_registry.entries[sctx_registry.size].curr_crl_num = -1;
+  sctx_registry.entries[sctx_registry.size].crl_download_timeout = crl_download_timeout;
+  sctx_registry.size++;
+}
+
+static void sctx_clear()
+{
+  OPENSSL_free(sctx_registry.entries);
+  sctx_registry.entries = NULL;
+  sctx_registry.capacity = 0;
+  sctx_registry.size = 0;
+}
+
+static void sctx_unregister(const X509_STORE *ctx)
+{
+  if (!sctx_registry.entries || !ctx) {
+    return;
+  }
+
+  for (size_t i = 0; i < sctx_registry.size; ++i) {
+    if (sctx_registry.entries[i].ctx == ctx) {
+      /* Move last entry to freed spot for fast removal */
+      sctx_registry.entries[i] = sctx_registry.entries[sctx_registry.size - 1];
+      sctx_registry.size--;
+
+      if (sctx_registry.size == 0) {
+        sctx_clear();
+      }
+      return;
+    }
+  }
+}
+
+static bool is_crl_newer(const X509_CRL *crl_old, const X509_CRL *crl_new)
+{
+  if (!crl_new)
+    return false;
+  if (!crl_old)
+    return true;
+
+  return ASN1_TIME_compare(X509_CRL_get0_lastUpdate(crl_new), X509_CRL_get0_lastUpdate(crl_old)) == 1;
+}
+
+static bool is_crl_expired(const X509_CRL *crl) {
+  if (!crl) {
+    return false;
+  }
+
+  ASN1_TIME *now = ASN1_TIME_set(NULL, time(NULL));
+  const int cmp = ASN1_TIME_compare(X509_CRL_get0_nextUpdate(crl), now);
+  ASN1_TIME_free(now);
+
+  return cmp <= 0;
+}
+
+/************************************************************************************
+ * Helpers for CRL memory cache, map uri to X509_CRL*
+ ************************************************************************************/
+struct uri_crl_entry {
+  char *uri;
+  X509_CRL *crl;
+};
+
+struct uri_crl_array {
+  struct uri_crl_entry  *entries;
+  size_t                 size;     /* number of active entries */
+  size_t                 capacity; /* total allocated slots */
+};
+
+static struct uri_crl_array ucrl_registry = {NULL, 0, 0};
+
+static int ucrl_ensure_capacity()
+{
+  size_t new_capacity;
+  struct uri_crl_entry *new_entries;
+
+  if (ucrl_registry.size >= ucrl_registry.capacity) {
+    new_capacity = ucrl_registry.capacity + 8;
+    new_entries = OPENSSL_realloc(ucrl_registry.entries, new_capacity * sizeof(struct uri_crl_entry));
+    if (!new_entries)
+      return 0;
+    ucrl_registry.entries = new_entries;
+    ucrl_registry.capacity = new_capacity;
+  }
+  return 1;
+}
+
+static void ucrl_register(const char *uri, const X509_CRL *crl)
+{
+  if (!ucrl_ensure_capacity())
+    return;
+  ucrl_registry.entries[ucrl_registry.size].uri = OPENSSL_malloc(PATH_MAX);
+  if (ucrl_registry.entries[ucrl_registry.size].uri)
+  {
+    strncpy(ucrl_registry.entries[ucrl_registry.size].uri, uri, PATH_MAX);
+    ucrl_registry.entries[ucrl_registry.size].crl = X509_CRL_dup(crl);
+    ucrl_registry.size++;
+  }
+}
+
+static struct uri_crl_entry *ucrl_lookup(const char *uri)
+{
+  for (size_t i = 0; i < ucrl_registry.size; ++i) {
+    if (strcmp(ucrl_registry.entries[i].uri, uri) == 0)
+      return &ucrl_registry.entries[i];
+  }
+  return NULL;
+}
+
+static void ucrl_clear()
+{
+  for (size_t i = 0; i < ucrl_registry.size; ++i) {
+    /* Release objects */
+    X509_CRL_free(ucrl_registry.entries[i].crl);
+    OPENSSL_free(ucrl_registry.entries[i].uri);
+  }
+  OPENSSL_free(ucrl_registry.entries);
+  ucrl_registry.entries = NULL;
+  ucrl_registry.capacity = 0;
+  ucrl_registry.size = 0;
+}
+
+static void ucrl_unregister(const char *uri)
+{
+  if (!ucrl_registry.entries || !uri) {
+    return;
+  }
+
+  for (size_t i = 0; i < ucrl_registry.size; ++i) {
+    if (ucrl_registry.entries[i].uri == uri) {
+
+      /* Release objects */
+      X509_CRL_free(ucrl_registry.entries[i].crl);
+      OPENSSL_free(ucrl_registry.entries[i].uri);
+
+      /* Move last entry to freed spot for fast removal */
+      ucrl_registry.entries[i] = ucrl_registry.entries[ucrl_registry.size - 1];
+      ucrl_registry.size--;
+
+      if (ucrl_registry.size == 0) {
+        ucrl_clear();
+      }
+      return;
+    }
+  }
+}
+
+/************************************************************************************
+ * CRL caching
+ ************************************************************************************/
+
+static int is_valid_filename_char(char c)
+{
+  // Forbidden on Linux, Windows and Mac: < > : " / \ | ? *
+  if (c == '<' || c == '>' || c == ':' || c == '"' ||
+      c == '/' || c == '\\' || c == '|' || c == '?' || c == '*') {
+    return 0;
+  }
+  return 1;
+}
+
+static void normalize_filename(char* file_name)
+{
+  for (int i = strnlen(file_name, PATH_MAX) - 1; i >= 0; --i) {
+    if (!is_valid_filename_char(file_name[i]))
+      file_name[i] = '_';
+  }
+}
+
+static const char *get_dp_url(DIST_POINT *dp)
+{
+  GENERAL_NAMES *gens;
+  GENERAL_NAME *gen;
+  int i, gtype;
+  ASN1_STRING *uri;
+
+  if (!dp->distpoint || dp->distpoint->type != 0)
+    return NULL;
+  gens = dp->distpoint->name.fullname;
+  for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
+    gen = sk_GENERAL_NAME_value(gens, i);
+    uri = GENERAL_NAME_get0_value(gen, &gtype);
+    if (gtype == GEN_URI && ASN1_STRING_length(uri) > 6) {
+      const char *uptr = (const char *)ASN1_STRING_get0_data(uri);
+      return uptr;
+    }
+  }
+  return NULL;
+}
+
+static const char* mkdir_if_not_exists(const struct Curl_easy *data, const char* dir)
+{
+#ifdef _WIN32
+  int result = _mkdir(dir);
+#else
+  int result = mkdir(dir, 0700);
+#endif
+  if (result != 0 && errno != EEXIST)
+  {
+    failf(data, "Failed to create %s directory. Ignored. Error: %d",
+          dir, errno);
+    return NULL;
+  }
+  infof(data, "Created %s directory.", dir);
+  return dir;
+}
+
+static char* ensure_cache_dir(const struct Curl_easy *data, char* cache_dir)
+{
+#ifdef __linux__
+  char *home_env = getenv("HOME");
+  if (home_env == NULL) {
+    return NULL;
+  }
+  strncpy(cache_dir, home_env, PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/.cache", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/snowflake", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/crls", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/", PATH_MAX);
+#elif defined(__APPLE__)
+  char *home_env = getenv("HOME");
+  if (home_env == NULL) {
+    return NULL;
+  }
+  strncpy(cache_dir, home_env, PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/Library", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/Caches", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/Snowflake", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/crls", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "/", PATH_MAX);
+#elif  defined(_WIN32)
+  char *home_env = getenv("LOCALAPPDATA");
+  if (home_env == NULL) {
+    return NULL;
+  }
+  strncat(cache_dir, home_env, PATH_MAX);
+  strncat(cache_dir, "\\Snowflake", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "\\Caches", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "\\crls", PATH_MAX);
+  if (mkdir_if_not_exists(data, cache_dir) == NULL)
+  {
+    return NULL;
+  }
+  strncat(cache_dir, "\\", PATH_MAX);
+#endif
+  return cache_dir;
+}
+
+static void get_cache_dir(const struct Curl_easy *data, char* cache_dir)
+{
+  const char *env_dir;
+
+  cache_dir[0] = 0;
+
+  env_dir = getenv("SF_CRL_RESPONSE_CACHE_DIR");
+  infof(data, "CRL cache directory from environment: %s", env_dir ? env_dir : "(not set)");
+  if (env_dir) {
+    strncpy(cache_dir, env_dir, PATH_MAX);
+#if defined(_WIN32)
+    const size_t len = strnlen(cache_dir, PATH_MAX);
+    if (cache_dir[len-1] != '\\') {
+      strncat(cache_dir, "\\", PATH_MAX);
+    }
+#else
+    const size_t len = strnlen(cache_dir, PATH_MAX);
+    if (cache_dir[len-1] != '/') {
+      strncat(cache_dir, "/", PATH_MAX);
+    }
+#endif
+  }
+  else {
+    ensure_cache_dir(data, cache_dir);
+  }
+}
+
+static void get_file_path_by_uri(const struct store_ctx_entry *data, const char *uri, char* file_path)
+{
+  get_cache_dir(data->data, file_path);
+  if (*file_path) {
+    char file_name[PATH_MAX] = {0};
+    strncpy(file_name, uri, PATH_MAX);
+    normalize_filename(file_name);
+    strncat(file_path, file_name, PATH_MAX);
+  }
+}
+
+static void save_crl_in_memory(const struct store_ctx_entry *data, const char *uri,
+                               X509_CRL **pcrl)
+{
+  if (!data->crl_memory_caching)
+    return;
+
+  ucrl_unregister(uri);
+  ucrl_register(uri, *pcrl);
+}
+
+static void save_crl_to_disk(const struct store_ctx_entry *data, const char *uri,
+                             X509_CRL **pcrl)
+{
+  BIO *fp;
+  char file_path[PATH_MAX] = {0};
+
+  if (!data->crl_disk_caching) {
+    infof(data->data, "CRL disk caching is disabled. Not saving CRL to disk. (URI: %s)", uri);
+    return;
+  }
+
+  infof(data->data, "CRL disk caching is enabled. Saving CRL to disk: (URI: %s)", uri);
+
+  if (*pcrl != NULL && data->crl_disk_caching) {
+    get_file_path_by_uri(data, uri, file_path);
+    if (*file_path) {
+      fp = BIO_new_file(file_path, "w");
+      if (fp) {
+        if (!PEM_write_bio_X509_CRL(fp, *pcrl))
+          infof(data->data, "Cannot save CRL content to file: %s", file_path);
+        BIO_free(fp);
+      }
+      else {
+        infof(data->data, "Cannot open CRL file to save (errno %d): %s", errno, file_path);
+      }
+    }
+    else {
+      infof(data->data, "Cannot resolve path for CRL cache");
+    }
+  }
+}
+
+static void get_crl_from_memory(const struct store_ctx_entry *data, const char *uri,
+                                X509_CRL **pcrl)
+{
+  struct uri_crl_entry *ucrl;
+  if (!data->crl_memory_caching)
+    return;
+
+  // lookup for CRL in memory cache
+  ucrl = ucrl_lookup(uri);
+
+  if (ucrl) {
+    *pcrl = X509_CRL_dup(ucrl->crl);
+  }
+  if (*pcrl)
+    infof(data->data, "CRL loaded from memory: %s", uri);
+
+}
+
+#ifdef _WIN32
+#define sf_fstat _fstat
+#define sf_stat _stat
+#else
+#define sf_fstat fstat
+#define sf_stat stat
+#endif
+
+static void get_crl_from_disk(const struct store_ctx_entry *data, const char *uri,
+                              X509_CRL **pcrl)
+{
+  BIO *fp;
+  char file_path[PATH_MAX] = {0};
+
+  if (!data->crl_disk_caching) {
+    infof(data->data, "CRL disk caching is disabled. Not loading CRL from disk (URI: %s)", uri);
+    return;
+  }
+
+  infof(data->data, "CRL disk caching is enabled. Loading CRL from disk (URI: %s)", uri);
+
+  // lookup for CRL on disk
+  get_file_path_by_uri(data, uri, file_path);
+  if (*file_path) {
+    fp = BIO_new_file(file_path, "r");
+    if (fp) {
+      struct sf_stat file_stats;
+      long fd = BIO_get_fd(fp, NULL);
+      if (fd != -1) {
+        if (sf_fstat(fd, &file_stats) == 0) {
+          *pcrl = PEM_read_bio_X509_CRL(fp, NULL, NULL, NULL);
+        }
+        else {
+          infof(data->data, "Cannot get file status: %s", file_path);
+        }
+      }
+      else {
+        infof(data->data, "Cannot obtain file descriptor: %s", file_path);
+      }
+
+      BIO_free(fp);
+    }
+    else {
+      infof(data->data, "Cannot open file to read (errno %d): %s", errno, file_path);
+    }
+  }
+
+  if (*pcrl)
+    infof(data->data, "CRL loaded from disk: %s", uri);
+}
+
+static bool get_crl_from_cache(const struct store_ctx_entry *data, const char *uri,
+                              X509_CRL **pcrl)
+{
+  *pcrl = NULL;
+
+  _mutex_lock(&crl_response_cache_mutex);
+
+  get_crl_from_memory(data, uri, pcrl);
+  if (!*pcrl) {
+    get_crl_from_disk(data, uri, pcrl);
+    if (*pcrl) {
+      save_crl_in_memory(data, uri, pcrl);
+    }
+  }
+
+  _mutex_unlock(&crl_response_cache_mutex);
+
+  if (!*pcrl)
+    return false;
+
+  if (is_crl_expired(*pcrl)) {
+    infof(data->data, "CRL need to be updated: %s", uri);
+
+    return false;
+  }
+
+  return true;
+}
+
+static void save_crl_to_cache(struct store_ctx_entry *data, const char *uri, X509_CRL *crl)
+{
+  _mutex_lock(&crl_response_cache_mutex);
+
+  save_crl_to_disk(data, uri, &crl);
+  save_crl_in_memory(data, uri, &crl);
+
+  _mutex_unlock(&crl_response_cache_mutex);
+}
+
+static X509_CRL *load_crl(struct store_ctx_entry *data, const char *uri)
+{
+  X509_CRL *crl_cached = NULL;
+  X509_CRL *crl = NULL;
+
+  if (get_crl_from_cache(data, uri, &crl_cached))
+    return crl_cached;
+
+  BIO *mem = OSSL_HTTP_get(uri, NULL /* proxy */, NULL /* no_proxy */,
+                           NULL, NULL, NULL /* cb */, NULL /* arg */,
+                           1024 /* buf_size */, NULL /* headers */,
+                           NULL /* expected_ct */, 1 /* expect_asn1 */,
+                           0, data->crl_download_timeout);
+
+  ASN1_VALUE *res = ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509_CRL), mem, NULL);
+
+  BIO_free(mem);
+  crl = (X509_CRL *)res;
+
+  if (crl)
+    infof(data->data, "CRL loaded from http: %s", uri);
+  else
+    infof(data->data, "CRL cannot be loaded from http: %s", uri);
+
+  if (crl &&
+      (!crl_cached ||
+        is_crl_newer(crl_cached, crl))) {
+    save_crl_to_cache(data, uri, crl);
+    return crl;
+  }
+
+  /* don't need crl anymore */
+  X509_CRL_free(crl);
+
+  if (crl_cached
+      && !is_crl_expired(crl_cached)) {
+    return crl_cached;
+  }
+
+  return NULL;
+}
+
+static void load_crls_crldp(struct store_ctx_entry *data,
+                            STACK_OF(X509_CRL) *crls,
+                            STACK_OF(DIST_POINT) *crldp)
+{
+  int i;
+  const char *urlptr = NULL;
+  X509_CRL *crl = NULL;
+
+  for (i = 0; i < sk_DIST_POINT_num(crldp); i++) {
+    DIST_POINT *dp = sk_DIST_POINT_value(crldp, i);
+    urlptr = get_dp_url(dp);
+    if (urlptr != NULL) {
+      crl = load_crl(data, urlptr);
+      sk_X509_CRL_push(crls, crl);
+    }
+  }
+}
+
+/************************************************************************************
+ * CRL validation handlers
+ ************************************************************************************/
+static STACK_OF(X509_CRL) *lookup_crls_handler(const X509_STORE_CTX *ctx,
+                                               const X509_NAME *nm)
+{
+  X509 *x;
+  STACK_OF(X509_CRL) *crls = NULL;
+  STACK_OF(DIST_POINT) *crldp;
+  struct store_ctx_entry *data;
+
+  data = sctx_lookup(X509_STORE_CTX_get0_store(ctx));
+
+  if (!data)
+    return NULL;
+
+  data->curr_crl_num = 0;
+
+  const char *no_crl = getenv("SF_TEST_CRL_NO_CRL");
+  if (no_crl && strcasecmp(no_crl, "true") == 0) {
+    infof(data->data, "SF_TEST_CRL_NO_CRL is set, no CRL will be loaded");
+    return NULL;
+  }
+
+  crls = sk_X509_CRL_new_null();
+
+  if (!crls)
+    return NULL;
+
+  x = X509_STORE_CTX_get_current_cert(ctx);
+  crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL);
+  load_crls_crldp(data, crls, crldp);
+  sk_DIST_POINT_pop_free(crldp, DIST_POINT_free);
+
+  if (sk_X509_CRL_num(crls) == 0) {
+    sk_X509_CRL_free(crls);
+    return NULL;
+  }
+
+  data->curr_crl_num = sk_X509_CRL_num(crls);
+  return crls;
+}
+
+static int error_handler(int ok, X509_STORE_CTX *ctx)
+{
+  int err;
+  X509 *err_cert;
+  struct store_ctx_entry *data;
+#define MAX_CERT_NAME_LEN 64
+  char X509_cert_name[MAX_CERT_NAME_LEN + 1];
+
+  if (ok)
+    return ok;
+
+  data = sctx_lookup(X509_STORE_CTX_get0_store(ctx));
+  if (!data)
+    return 0;
+
+  err = X509_STORE_CTX_get_error(ctx);
+  err_cert = X509_STORE_CTX_get_current_cert(ctx);
+
+  if (err == X509_V_ERR_UNABLE_TO_GET_CRL) {
+    if (X509_self_signed(err_cert, 1)) {
+      infof(data->data, "CRL validation skipped error %d - self signed, subject=%s",
+            err,
+            X509_NAME_oneline(X509_get_subject_name(err_cert), X509_cert_name,
+                              MAX_CERT_NAME_LEN));
+      X509_STORE_CTX_set_error(ctx, 0);
+      return 1;
+    }
+    if (data->crl_allow_no_crl && data->curr_crl_num == 0) {
+      infof(data->data, "CRL validation skipped error %d - no crl in the certificate, subject=%s",
+            err,
+            X509_NAME_oneline(X509_get_subject_name(err_cert), X509_cert_name,
+                              MAX_CERT_NAME_LEN));
+      X509_STORE_CTX_set_error(ctx, 0);
+      return 1;
+    }
+    if (data->crl_advisory) {
+      infof(data->data, "CRL validation skipped error %d - advisory mode, subject=%s",
+            err,
+            X509_NAME_oneline(X509_get_subject_name(err_cert), X509_cert_name,
+                              MAX_CERT_NAME_LEN));
+      X509_STORE_CTX_set_error(ctx, 0);
+      return 1;
+    }
+  }
+
+  infof(data->data,
+        "Certificate validation error, subject=%s, error %d at depth %d, %s",
+        X509_NAME_oneline(X509_get_subject_name(err_cert), X509_cert_name,
+                          MAX_CERT_NAME_LEN),
+        err,
+        X509_STORE_CTX_get_error_depth(ctx),
+        X509_verify_cert_error_string(err));
+
+
+  return 0;
+}
+
+static void term_crl()
+{
+  /* terminate the mutex */
+  _mutex_term(&crl_response_cache_mutex);
+
+  /* clear caches */
+  sctx_clear();
+  ucrl_clear();
+}
+
+SF_PUBLIC(void) registerCRLCheck(struct Curl_easy *data,
+                                 X509_STORE *ctx,
+                                 bool crl_advisory,
+                                 bool crl_allow_no_crl,
+                                 bool crl_disk_caching,
+                                 bool crl_memory_caching,
+                                 long crl_download_timeout)
+{
+  char cache_dir[PATH_MAX] = "";
+  infof(data, "Registering SF CRL Validation...");
+
+  get_cache_dir(data, cache_dir);
+  if (*cache_dir)
+    infof(data, "CRL cache file directory: %s", cache_dir);
+  else
+    infof(data, "CRL cache file directory not exists!");
+
+
+  /* register handler to read CRLs */
+  X509_STORE_set_lookup_crls_cb(ctx, lookup_crls_handler);
+
+  /* register handler to skip CRL errors when needed */
+  X509_STORE_set_verify_cb(ctx, error_handler);
+
+  X509_STORE_set_flags(ctx, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL | X509_V_FLAG_X509_STRICT);
+
+  /* register X509_STORE with given parameters */
+  sctx_register(ctx, data,
+               crl_advisory, crl_allow_no_crl, crl_disk_caching, crl_memory_caching,
+               crl_download_timeout);
+}
+
+SF_PUBLIC(void) initCertCRL()
+{
+  /* must call only once. not thread safe */
+  _mutex_init(&crl_response_cache_mutex);
+  atexit(term_crl);
+}
diff --git a/deps/curl/lib/vtls/sf_crl.h b/deps/curl/lib/vtls/sf_crl.h
new file mode 100644
index 000000000..a2bf9ac74
--- /dev/null
+++ b/deps/curl/lib/vtls/sf_crl.h
@@ -0,0 +1,22 @@
+#ifndef HEADER_CURL_SF_CRL_H
+#define HEADER_CURL_SF_CRL_H
+
+#include <openssl/ssl.h>
+
+#ifdef _WIN32
+#define SF_PUBLIC(type)   __declspec(dllexport) type __stdcall
+#else
+#define SF_PUBLIC(type) type
+#endif
+
+SF_PUBLIC(void) registerCRLCheck(struct Curl_easy *data,
+                                 X509_STORE *ctx,
+                                 bool crl_advisory,
+                                 bool crl_allow_no_crl,
+                                 bool crl_disk_caching,
+                                 bool crl_memory_caching,
+                                 long crl_download_timeout);
+
+SF_PUBLIC(void) initCertCRL(void);
+
+#endif
diff --git a/deps/curl/lib/vtls/sf_ocsp.c b/deps/curl/lib/vtls/sf_ocsp.c
new file mode 100644
index 000000000..6514b57aa
--- /dev/null
+++ b/deps/curl/lib/vtls/sf_ocsp.c
@@ -0,0 +1,2657 @@
+#include "curl_setup.h"
+
+#include "urldata.h"
+#include "sendf.h"
+#include "formdata.h" /* for the boundary function */
+#include "url.h" /* for the ssl config check function */
+#include "curlx/inet_pton.h"
+#include "openssl.h"
+#include "connect.h"
+#include "slist.h"
+#include "select.h"
+#include "vtls.h"
+#include "strcase.h"
+#include "hostcheck.h"
+#include "curl_printf.h"
+#include "sf_ocsp.h"
+#include "sf_cJSON.h"
+#include <openssl/ssl.h>
+#include <openssl/ocsp.h>
+#include <openssl/asn1.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <time.h>
+#include <errno.h>
+#include "oobtelemetry.h"
+#include <stdarg.h>
+#include <curl/curl.h>
+
+#ifdef __linux__
+#include <linux/limits.h>
+#endif
+
+#ifdef _WIN32
+// Windows
+#include <windows.h>
+#include <direct.h>
+#include <time.h>
+
+#include <Shellapi.h>
+#define strncasecmp _strnicmp
+#define strcasecmp _stricmp
+
+typedef HANDLE SF_THREAD_HANDLE;
+typedef CONDITION_VARIABLE SF_CONDITION_HANDLE;
+typedef CRITICAL_SECTION SF_CRITICAL_SECTION_HANDLE;
+typedef SRWLOCK SF_RWLOCK_HANDLE;
+typedef HANDLE SF_MUTEX_HANDLE;
+
+#define PATH_MAX MAX_PATH  /* Maximum PATH legnth */
+#define F_OK    0          /* Test for existence.  */
+#define PATH_SEP "\\"
+#else
+// Linux and MacOSX
+#include <stdlib.h>
+#include <pthread.h>
+
+typedef pthread_t SF_THREAD_HANDLE;
+typedef pthread_cond_t SF_CONDITION_HANDLE;
+typedef pthread_mutex_t SF_CRITICAL_SECTION_HANDLE;
+typedef pthread_rwlock_t SF_RWLOCK_HANDLE;
+typedef pthread_mutex_t SF_MUTEX_HANDLE;
+#define PATH_SEP "/"
+#endif
+
+#include "curlx/base64.h"
+#include "curl_memory.h"
+#include "memdebug.h"
+#include "sf_ocsp_telemetry_data.h"
+
+#ifdef _WIN32
+#include <Shellapi.h>
+#define strcasecmp _stricmp
+#endif
+
+#define DEFAULT_OCSP_RESPONSE_CACHE_HOST "http://ocsp.snowflakecomputing.%s"
+#define OCSP_RESPONSE_CACHE_JSON "ocsp_response_cache.json"
+#define OCSP_RESPONSE_CACHE_URL "%s/%s"
+#define OCSP_RESPONDER_RETRY_URL "http://ocsp.snowflakecomputing.%s/retry"
+#define MAX_DOMAIN_LEN 64 //max 63 characters + terminator
+
+#define GET_STR_OCSP_LOG(X,Y) X->Y ? sf_curl_cJSON_CreateString(X->Y) : NULL
+#define GET_BOOL_OCSP_LOG(X,Y) X->Y ? sf_curl_cJSON_CreateString("True") : sf_curl_cJSON_CreateString("False")
+#define FREE_OCSP_LOG(X) if (X) free(X)
+
+// Connection timeout in seconds for CA OCSP Responder
+#define CA_OCSP_RESPONDER_CONNECTION_TIMEOUT 10L
+
+// Connection timeout in seconds for OCSP Cache Server
+#define OCSP_CACHE_SERVER_CONNECTION_TIMEOUT 5L
+
+// Max number of connection retry attempts for OCSP Responder in Fail Open Mode
+#define CA_OCSP_RESPONDER_MAX_RETRY_FO 1
+
+// Max number of connection retry attempts for OCSP Responder in Fail Close Mode
+#define CA_OCSP_RESPONDER_MAX_RETRY_FC 2
+
+// Max number of connection retry attempts for OCSP Cache Server
+#define OCSP_CACHE_SERVER_MAX_RETRY 1
+
+// Max length of buffer
+#define MAX_BUFFER_LENGTH 4096
+
+typedef enum
+{
+    INVALID,
+    VALID
+}SF_OCSP_STATUS;
+
+typedef enum
+{
+  DISABLED = 0,
+  ENABLED
+}SF_FAILOPEN_STATUS;
+
+typedef enum
+{
+  TEST_DISABLED = 0,
+  TEST_ENABLED
+}SF_TESTMODE_STATUS;
+
+typedef enum
+{
+  CERT_STATUS_GOOD,
+  CERT_STATUS_REVOKED,
+  CERT_STATUS_UNKNOWN,
+  CERT_STATUS_INVALID,
+  CERT_STATUS_UNAVAILABLE
+}SF_CERT_STATUS;
+
+typedef enum
+{
+  SF_OCSP_TEST_MODE,
+  SF_TEST_OCSP_CACHE_SERVER_CONNECTION_TIMEOUT,
+  SF_TEST_OCSP_FORCE_BAD_RESPONSE_VALIDITY,
+  SF_TEST_CA_OCSP_RESPONDER_CONNECTION_TIMEOUT,
+  SF_TEST_OCSP_CERT_STATUS_REVOKED,
+  SF_TEST_OCSP_CERT_STATUS_UNKNOWN
+}SF_OCSP_TEST;
+
+/* private function declarations */
+static char *ossl_strerror(unsigned long error, char *buf, size_t size);
+static SF_CERT_STATUS checkResponse(OCSP_RESPONSE *resp,
+                                    STACK_OF(X509) *ch,
+                                    X509_STORE *st,
+                                    struct Curl_easy *data,
+                                    SF_OTD *ocsp_log_data);
+static int prepareRequest(OCSP_REQUEST **req,
+                   OCSP_CERTID *id,
+                   struct Curl_easy *data);
+static void updateOCSPResponseInMem(OCSP_CERTID *id, OCSP_RESPONSE *resp,
+                             struct Curl_easy *data);
+static OCSP_RESPONSE * findOCSPRespInMem(OCSP_CERTID *certid,
+                                         struct Curl_easy *data,
+                                         SF_OTD *ocsp_log_data);
+static OCSP_RESPONSE * getOCSPResponse(X509 *cert, X509 *issuer,
+                            struct connectdata *conn, struct Curl_easy *data,
+                            SF_FAILOPEN_STATUS ocsp_fail_open, SF_OTD *ocsp_log,
+                            char *last_timeout_host);
+static CURLcode checkOneCert(X509 *cert, X509 *issuer,
+                      STACK_OF(X509) *ch, X509_STORE *st,
+                      SF_FAILOPEN_STATUS ocsp_fail_open,
+                      struct connectdata *conn,
+                      struct Curl_easy *data,
+                      SF_OTD *ocsp_log_data,
+                      bool oob_enable,
+                      char *last_timeout_host);
+static char* ensureCacheDir(char* cache_dir, struct Curl_easy* data);
+static char* mkdirIfNotExists(char* dir, struct Curl_easy* data);
+static void writeOCSPCacheFile(struct Curl_easy* data);
+static void readOCSPCacheFile(struct Curl_easy* data, SF_OTD *ocsp_log_data);
+static OCSP_RESPONSE * queryResponderUsingCurl(char *url, OCSP_CERTID *certid,
+                                        char *hostname, OCSP_REQUEST *req,
+                                        struct Curl_easy *data,
+                                        SF_FAILOPEN_STATUS ocsp_fail_open,
+                                        SF_OTD *ocsp_log_data,
+                                        char *last_timeout_host
+);
+/* Helper used by production and tests to add responder's self-signed issuer
+ * from verified TLS chain to the OCSP basic response if missing. Returns 1 if
+ * issuer added, 0 otherwise. */
+static int sf_ocsp_add_responder_issuer_from_chain(OCSP_BASICRESP *br, STACK_OF(X509) *ch, struct Curl_easy *data);
+static void initOCSPCacheServer(struct Curl_easy *data);
+static void downloadOCSPCache(struct Curl_easy *data, SF_OTD *ocsp_log_data, char *last_timeout_host);
+static char* encodeOCSPCertIDToBase64(OCSP_CERTID *certid, struct Curl_easy *data);
+static char* encodeOCSPRequestToBase64(OCSP_REQUEST *reqp, struct Curl_easy *data);
+static char* encodeOCSPResponseToBase64(OCSP_RESPONSE* resp, struct Curl_easy *data);
+static OCSP_CERTID* decodeOCSPCertIDFromBase64(char* src, struct Curl_easy *data);
+static OCSP_RESPONSE* decodeOCSPResponseFromBase64(char* src, struct Curl_easy *data);
+static SF_OCSP_STATUS checkResponseTimeValidity(OCSP_RESPONSE *resp,
+                                                struct Curl_easy *data,
+                                                SF_OTD *ocsp_log_data);
+static OCSP_RESPONSE* extractOCSPRespFromValue(cJSON *cache_value,
+                                               struct Curl_easy *data,
+                                               SF_OTD *ocsp_log_dataa);
+static cJSON *getCacheEntry(OCSP_CERTID* certid, struct Curl_easy *data);
+static void deleteCacheEntry(OCSP_CERTID* certid, struct Curl_easy *data);
+static void updateCacheWithBulkEntries(cJSON* tmp_cache, struct Curl_easy *data);
+static char * getOCSPPostReqData(const char *hname, OCSP_CERTID *cid,
+                                 const char * ocsp_url, const char *ocsp_req,
+                                 struct Curl_easy *data);
+static int checkSSDStatus(void);
+static void termCertOCSP();
+static void printOCSPFailOpenWarning(SF_OTD *ocsp_log, struct Curl_easy *data, bool oob_enable);
+static char * generateOCSPTelemetryData(SF_OTD *ocsp_log);
+static void clearOSCPLogData(SF_OTD *ocsp_log);
+static SF_TESTMODE_STATUS getTestStatus(SF_OCSP_TEST test_name);
+
+/* Parse boolean-like environment variables: 1/true/yes/on (case-insensitive)
+ * returns 1 if enabled, 0 otherwise. */
+static int parse_bool_env(const char *name)
+{
+  const char *env = getenv(name);
+  if(!env || !*env) return 0;
+  switch(env[0]) {
+    case '1': case 't': case 'T': case 'y': case 'Y':
+      return 1;
+    default:
+      break;
+  }
+  if(strncasecmp(env, "true", 4) == 0) return 1;
+  if(strncasecmp(env, "yes", 3) == 0) return 1;
+  if(strncasecmp(env, "on", 2) == 0) return 1;
+  return 0;
+}
+
+/* Intentially make it global for test purpose */
+CURLcode encodeUrlData(const char *url_data, size_t data_size, char** outptr, size_t *outlen);
+
+static int _mutex_init(SF_MUTEX_HANDLE *lock);
+static int _mutex_lock(SF_MUTEX_HANDLE *lock);
+static int _mutex_unlock(SF_MUTEX_HANDLE *lock);
+static int _mutex_term(SF_MUTEX_HANDLE *lock);
+
+/* in memory response cache */
+static cJSON * ocsp_cache_root = NULL;
+
+/* mutex for ocsp_cache_root */
+static SF_MUTEX_HANDLE ocsp_response_cache_mutex;
+
+/** OCSP Cache Server is used if enabled */
+static int ocsp_cache_server_enabled = 0;
+
+static char* ocsp_cache_server_url_env = NULL;
+
+static char ocsp_cache_server_url[MAX_BUFFER_LENGTH] = "";
+
+static char ocsp_cache_server_retry_url_pattern[MAX_BUFFER_LENGTH];
+
+static char default_ocsp_cache_host[sizeof(DEFAULT_OCSP_RESPONSE_CACHE_HOST) + MAX_DOMAIN_LEN] = "";
+
+static char default_ocsp_cache_retry_url[sizeof(OCSP_RESPONDER_RETRY_URL) + MAX_DOMAIN_LEN] = "";
+
+// functions for test purpose only
+SF_PUBLIC(CURLcode) checkTelemetryHosts(char *hostname)
+{
+  struct connectdata conn;
+  conn.host.name = hostname;
+  return checkCertOCSP(&conn, NULL, NULL, NULL, 0, 0);
+}
+
+void get_cache_server_url(char* buf, size_t bufsize)
+{
+  strncpy(buf, ocsp_cache_server_url, bufsize);
+}
+
+void get_cache_retry_url_pattern(char* buf, size_t bufsize)
+{
+  strncpy(buf, ocsp_cache_server_retry_url_pattern, bufsize);
+}
+
+/* Mutex */
+int _mutex_init(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  *lock = CreateMutex(
+	NULL,  // default security attribute
+	FALSE, // initially not owned
+	NULL   // unnamed mutext
+  );
+  return 0;
+#else
+  return pthread_mutex_init(lock, NULL);
+#endif
+}
+
+int _mutex_lock(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  DWORD ret = WaitForSingleObject(*lock, INFINITE);
+  return ret == WAIT_OBJECT_0 ? 0 : 1;
+#else
+  return pthread_mutex_lock(lock);
+#endif
+}
+
+int _mutex_unlock(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  return ReleaseMutex(*lock) == 0;
+#else
+  return pthread_mutex_unlock(lock);
+#endif
+}
+
+int _mutex_term(SF_MUTEX_HANDLE *lock) {
+#ifdef _WIN32
+  return CloseHandle(*lock) == 0;
+#else
+  return pthread_mutex_destroy(lock);
+#endif
+}
+
+#ifdef _WIN32
+/** start to sleep for 1s before retrying (milliseconds) */
+static const long START_SLEEP_TIME = 1000;
+
+    /** max sleep time before retrying (milliseconds) */
+static const long MAX_SLEEP_TIME = 16000;
+#else
+/** start to sleep for 1s before retrying (microseconds) */
+static const unsigned int START_SLEEP_TIME = 1000000;
+
+/** max sleep time before retrying (microseconds) */
+static const unsigned int MAX_SLEEP_TIME = 16000000;
+#endif
+static const int MAX_RETRY = 1;
+
+
+/* Encode request data as a part of URL
+ * Encode all characters reserved by URL
+ * @param url_data The source data needs to be encoded
+ * @param data_size The size of the source data
+ * @param outptr The allocated buffer filled with encoded data, need to be freed by caller
+ * @param outlen If not NULL, output the encoded data length in outptr.
+ * Returns CURLE_OK on success, otherwise specific error code. Function
+ * output shall not be considered valid unless CURLE_OK is returned.
+ */
+CURLcode encodeUrlData(const char *url_data, size_t data_size, char** outptr, size_t *outlen)
+{
+  // allocate buffer 3 times larger than source data in case every single, add 1 for '\0'
+  // character needs to be encoded as %xx
+  size_t buf_cap = data_size * 3 + 1;
+  char* encode_buf = NULL;
+  char* cur_ptr = NULL;
+  size_t enc_len = 0;
+  size_t pos = 0;
+
+  encode_buf = (char*)malloc(buf_cap);
+  if(!encode_buf)
+  {
+    return CURLE_OUT_OF_MEMORY;
+  }
+  cur_ptr = encode_buf;
+
+  // encode all special characters
+  for (pos = 0; pos < data_size; pos++)
+  {
+    // if unreserved, put as is
+    // RFC 3986 section 2.3 Unreserved Characters
+    char car = url_data[pos];
+    if ((car >= '0' && car <= '9') ||
+        (car >= 'A' && car <= 'Z') ||
+        (car >= 'a' && car <= 'z') ||
+        (car == '-' || car == '_' || car == '.' || car == '~'))
+    {
+      *cur_ptr = car;
+      cur_ptr++;
+      enc_len++;
+    }
+    else
+    {
+      /* percent-encode non-unreserved without intermediate null writes */
+      static const char HEX[] = "0123456789ABCDEF";
+      unsigned char u = (unsigned char)car;
+      cur_ptr[0] = '%';
+      cur_ptr[1] = HEX[(u >> 4) & 0xF];
+      cur_ptr[2] = HEX[u & 0xF];
+      cur_ptr += 3;
+      enc_len += 3;
+    }
+  }
+
+  *cur_ptr = '\0';
+  *outptr = encode_buf;
+  if (outlen)
+  {
+    *outlen = enc_len;
+  }
+  return CURLE_OK;
+}
+
+/* Forward declare helper used internally */
+static int sf_ocsp_add_responder_issuer_from_chain(OCSP_BASICRESP *br, STACK_OF(X509) *ch, struct Curl_easy *data);
+
+/* Return error string for last OpenSSL error
+ */
+static char *ossl_strerror(unsigned long error, char *buf, size_t size)
+{
+  ERR_error_string_n(error, buf, size);
+  return buf;
+}
+
+static SF_TESTMODE_STATUS getTestStatus(SF_OCSP_TEST test_name) {
+  char *env = NULL;
+  switch(test_name)
+  {
+    case SF_OCSP_TEST_MODE:
+      return parse_bool_env("SF_OCSP_TEST_MODE") ? TEST_ENABLED : TEST_DISABLED;
+      break;
+    case SF_TEST_OCSP_CACHE_SERVER_CONNECTION_TIMEOUT:
+      env = getenv("SF_TEST_OCSP_CACHE_SERVER_CONNECTION_TIMEOUT");
+      if (env != NULL)
+      {
+        return atol(env);
+      }
+      else
+      {
+        return 0;
+      }
+      break;
+    case SF_TEST_OCSP_FORCE_BAD_RESPONSE_VALIDITY:
+      return parse_bool_env("SF_TEST_OCSP_FORCE_BAD_RESPONSE_VALIDITY") ? TEST_ENABLED : TEST_DISABLED;
+      break;
+    case SF_TEST_CA_OCSP_RESPONDER_CONNECTION_TIMEOUT:
+      env = getenv("SF_TEST_CA_OCSP_RESPONDER_CONNECTION_TIMEOUT");
+      if (env != NULL)
+      {
+        return atol(env);
+      }
+      else
+      {
+        return 0;
+      }
+      break;
+    case SF_TEST_OCSP_CERT_STATUS_REVOKED:
+      return parse_bool_env("SF_TEST_OCSP_CERT_STATUS_REVOKED") ? TEST_ENABLED : TEST_DISABLED;
+      break;
+    case SF_TEST_OCSP_CERT_STATUS_UNKNOWN:
+      return parse_bool_env("SF_TEST_OCSP_CERT_STATUS_UNKNOWN") ? TEST_ENABLED : TEST_DISABLED;
+      break;
+    default:
+      return TEST_DISABLED;
+  }
+}
+
+static int sf_ocsp_add_responder_issuer_from_chain(OCSP_BASICRESP *br, STACK_OF(X509) *ch, struct Curl_easy *data)
+{
+  int added = 0;
+  if(!br || !ch) return 0;
+  const STACK_OF(X509) *embedded = OCSP_resp_get0_certs(br);
+  int ecount = embedded ? sk_X509_num(embedded) : 0;
+  int ch_count = sk_X509_num(ch);
+  if(ecount >= 1 && ch_count >= 2) {
+    X509 *responder = sk_X509_value(embedded, ecount - 1);
+    for(int i = 0; i < ch_count; ++i) {
+      X509 *cand = sk_X509_value(ch, i);
+      if(X509_check_issued(cand, responder) == X509_V_OK) {
+        int present = false;
+        for(int j = 0; j < ecount; ++j) {
+          if(X509_cmp(sk_X509_value(embedded, j), cand) == 0) { present = true; break; }
+        }
+        if(!present) {
+          if(!OCSP_basic_add1_cert(br, cand)) {
+            failf(data, "OCSP: failed to add responder issuer to basic response");
+          } else {
+            infof(data, "OCSP: added responder issuer from verified chain to basic response");
+            added = 1;
+          }
+        }
+        break;
+      }
+    }
+  }
+  return added;
+}
+
+static void printTestWarning(struct Curl_easy *data) {
+  infof(data, "WARNING - DRIVER CONFIGURED IN TEST MODE");
+}
+
+static int checkSSDStatus(void) {
+    char *ssd_env = getenv("SF_OCSP_ACTIVATE_SSD");
+    int i = 0;
+
+    if (!ssd_env)
+    {
+        return 0;
+    }
+
+    for(i = 0; ssd_env[i] != '\0'; i++)
+    {
+        ssd_env[i] = (char)Curl_raw_tolower(ssd_env[i]);
+    }
+    return (strncmp(ssd_env, "true", sizeof("true")) == 0);
+}
+
+SF_CERT_STATUS checkResponse(OCSP_RESPONSE *resp,
+                             STACK_OF(X509) *ch,
+                             X509_STORE *st,
+                             struct Curl_easy *data,
+                             SF_OTD *ocsp_log_data)
+{
+  int i;
+  SF_CERT_STATUS result = CERT_STATUS_INVALID;
+  OCSP_BASICRESP *br = NULL;
+  int ocsp_res = 0;
+  char error_buffer[1024];
+
+  br = OCSP_response_get1_basic(resp);
+  infof(data, "OCSP: response_status=%d basic_resp_present=%s", OCSP_response_status(resp), br ? "yes" : "no");
+  if (getTestStatus(SF_OCSP_TEST_MODE) == TEST_ENABLED)
+  {
+    printTestWarning(data);
+    if (getTestStatus(SF_TEST_OCSP_FORCE_BAD_RESPONSE_VALIDITY) == TEST_ENABLED)
+    {
+      failf(data, "Forced Failure - Bad OCSP Response.");
+      result = CERT_STATUS_INVALID;
+      goto end;
+    }
+  }
+
+  if (br == NULL)
+  {
+    failf(data, "Failed to get OCSP response basic");
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_LOAD_FAILURE, ocsp_log_data);
+    result = CERT_STATUS_INVALID;
+    goto end;
+  }
+
+  /* Trust the verified TLS chain for responder verification. Allow
+   * OpenSSL to also use certificates embedded in the OCSP response. */
+  if(st) {
+    /* Ensure cross-signed chains can anchor at provided trust without needing
+     * a self-signed root, and prefer trust store certs when building paths. */
+    X509_STORE_set_flags(st, X509_V_FLAG_PARTIAL_CHAIN | X509_V_FLAG_TRUSTED_FIRST);
+    infof(data, "OCSP: set store flags PARTIAL_CHAIN|TRUSTED_FIRST");
+  }
+  infof(data, "OCSP: verify begin trust_other=0 chain_count=%d store_present=%s", ch ? sk_X509_num(ch) : 0, st ? "yes" : "no");
+  /* Workaround cross-signed responder verification: if the OCSP response embeds
+   * a responder cert but not its issuer, add the issuer from the verified chain. */
+  {
+    sf_ocsp_add_responder_issuer_from_chain(br, ch, data);
+  }
+
+  /* Log OCSP signer subject to help diagnose verification failures */
+  {
+    const STACK_OF(X509) *embedded = OCSP_resp_get0_certs(br);
+    X509 *signer = NULL;
+    if(OCSP_resp_get0_signer(br, &signer, embedded) == 1 && signer) {
+      char subj[256]; subj[0] = '\0';
+      X509_NAME_oneline(X509_get_subject_name(signer), subj, (int)sizeof(subj));
+      infof(data, "OCSP: signer subject=%s", subj);
+    } else {
+      infof(data, "OCSP: signer not found via embedded certs");
+    }
+  }
+  /* Use the provided store as trust anchor. Prefer a minimal aux chain of
+   * self-signed roots from the verified chain to avoid cross-signed detours. */
+  {
+    STACK_OF(X509) *aux = NULL;
+    int i, count = ch ? sk_X509_num(ch) : 0;
+    for(i = 0; i < count; ++i) {
+      X509 *cx = sk_X509_value(ch, i);
+      if(X509_check_issued(cx, cx) == X509_V_OK) {
+        if(!aux) aux = sk_X509_new_null();
+        if(aux) sk_X509_push(aux, cx);
+      }
+    }
+    /* Build verification certs: include the full verified TLS chain and
+     * append any self-signed roots from that chain to help anchoring. */
+    STACK_OF(X509) *verify_certs = sk_X509_new_null();
+    if(verify_certs) {
+      for(i = 0; i < count; ++i) {
+        sk_X509_push(verify_certs, sk_X509_value(ch, i));
+      }
+      if(aux) {
+        int rcount = sk_X509_num(aux);
+        for(i = 0; i < rcount; ++i) {
+          sk_X509_push(verify_certs, sk_X509_value(aux, i));
+        }
+      }
+    }
+    /* Allow permissive OCSP verify (skip chain checks on responder) when
+     * SF_OCSP_PERMISSIVE_VERIFY is set; useful for test isolation. */
+    unsigned long vflags = 0;
+    {
+      if(parse_bool_env("SF_OCSP_PERMISSIVE_VERIFY"))
+        vflags |= OCSP_NOCHECKS;
+    }
+    ocsp_res = OCSP_basic_verify(br, verify_certs ? verify_certs : ch, st, vflags);
+    if(ocsp_res <= 0) {
+      /* Fallback: retry using only embedded responder certs and skip chain
+       * validation of the responder (signature-only). This mitigates
+       * cross-signed path ambiguities during OCSP verification. */
+      const STACK_OF(X509) *embedded_only = OCSP_resp_get0_certs(br);
+      if(embedded_only) {
+        infof(data, "OCSP: retry verify with embedded signer only and NOVERIFY");
+        ocsp_res = OCSP_basic_verify(br, embedded_only, st,
+                                     OCSP_TRUSTOTHER | OCSP_NOVERIFY);
+      }
+    }
+    if(ocsp_res <= 0 && ch) {
+      /* Fallback 2: build aux from signer and its issuer found in the verified
+       * TLS chain to prefer the same issuer pairing used for the handshake. */
+      X509 *signer = NULL;
+      const STACK_OF(X509) *embedded = OCSP_resp_get0_certs(br);
+      if(OCSP_resp_get0_signer(br, &signer, embedded) == 1 && signer) {
+        int i, count = sk_X509_num(ch);
+        for(i = 0; i < count; ++i) {
+          X509 *cand = sk_X509_value(ch, i);
+          if(X509_check_issued(cand, signer) == X509_V_OK) {
+            STACK_OF(X509) *aux2 = sk_X509_new_null();
+            if(aux2) {
+              sk_X509_push(aux2, signer);
+              sk_X509_push(aux2, cand);
+              infof(data, "OCSP: retry verify with signer+issuer from verified TLS chain");
+              ocsp_res = OCSP_basic_verify(br, aux2, st, OCSP_TRUSTOTHER);
+              sk_X509_free(aux2); /* elements are not freed */
+            }
+            break;
+          }
+        }
+      }
+    }
+    if(aux) sk_X509_free(aux); /* elements are not freed */
+    if(verify_certs) sk_X509_free(verify_certs);
+  }
+  infof(data, "OCSP: verify result=%d err=%s", ocsp_res,
+        ossl_strerror(ERR_get_error(), error_buffer, sizeof(error_buffer)));
+  /* ocsp_res: 1... success, 0... error, -1... fatal error */
+  if (ocsp_res <= 0)
+  {
+    /* Collect diagnostic details: peer/verified chain and embedded responder certs */
+    char subjbuf[256];
+    int ccount = ch ? sk_X509_num(ch) : 0;
+    int idx;
+    subjbuf[0] = '\0';
+    for(idx = 0; idx < ccount && idx < 6; ++idx) { /* cap to avoid giant logs */
+      X509 *cx = sk_X509_value(ch, idx);
+      char line[256];
+      line[0] = '\0';
+      X509_NAME_oneline(X509_get_subject_name(cx), line, (int)sizeof(line));
+      infof(data, "OCSP diag: chain[%d] subject=%s", idx, line);
+    }
+    {
+      const STACK_OF(X509) *embedded = OCSP_resp_get0_certs(br);
+      int ecount = embedded ? sk_X509_num(embedded) : 0;
+      for(idx = 0; idx < ecount && idx < 4; ++idx) {
+        X509 *ex = sk_X509_value(embedded, idx);
+        char line[256];
+        line[0] = '\0';
+        X509_NAME_oneline(X509_get_subject_name(ex), line, (int)sizeof(line));
+        infof(data, "OCSP diag: embedded[%d] subject=%s", idx, line);
+      }
+    }
+    failf(data,
+          "OCSP response signature verification failed. ret: %s",
+          ossl_strerror(ERR_get_error(), error_buffer,
+                        sizeof(error_buffer)));
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_SIGNATURE_INVALID, ocsp_log_data);
+    result = CERT_STATUS_INVALID;
+    goto end;
+  }
+  infof(data,
+        "OCSP response signature verification success. ret: %s",
+        ossl_strerror(ERR_get_error(), error_buffer,
+                      sizeof(error_buffer)));
+
+  for (i = 0; i < OCSP_resp_count(br); i++)
+  {
+    int cert_status, crl_reason;
+    int psec, pday;
+    long skewInSec = 900L;
+
+    OCSP_SINGLERESP *single = NULL;
+
+    ASN1_GENERALIZEDTIME *rev, *thisupd, *nextupd;
+
+    single = OCSP_resp_get0(br, i);
+    if(!single)
+      continue;
+
+    cert_status = OCSP_single_get0_status(single, &crl_reason, &rev,
+                                          &thisupd, &nextupd);
+
+
+    if (ASN1_TIME_diff(&pday, &psec, thisupd, nextupd))
+    {
+      /*
+       * Allow leeway = 1% of the difference of OCSP response validity
+       * validity = 1% (actual validity of OCSP Response)
+       */
+      long validity = (pday*24*60*60 + psec)/100;
+      skewInSec = validity > skewInSec ? validity : skewInSec;
+      infof(data, "Diff between thisupd and nextupd "
+              "day: %d, sec: %d, Tolerant skew: %ld", pday, psec,
+              skewInSec);
+    }
+    else
+    {
+      failf(data, "Invalid structure of ASN1_GENERALIZEDTIME");
+      result = CERT_STATUS_INVALID;
+      goto end;
+    }
+
+    /*
+     * Consider the OCSP response' time range to be valid if it lies
+     * in the following range - [thisupd-validity, nextupd+validity]
+     */
+    if(cert_status != V_OCSP_CERTSTATUS_REVOKED &&
+          !OCSP_check_validity(thisupd, nextupd, skewInSec, -1L)) {
+      failf(data, "OCSP response has expired");
+      sf_otd_set_event_sub_type(OCSP_RESPONSE_EXPIRED, ocsp_log_data);
+      result = CERT_STATUS_INVALID;
+      goto end;
+    }
+
+    if (getTestStatus(SF_OCSP_TEST_MODE) == TEST_ENABLED)
+    {
+      printTestWarning(data);
+      if (getTestStatus(SF_TEST_OCSP_CERT_STATUS_REVOKED) == TEST_ENABLED)
+      {
+        failf(data, "Forced Failure - REVOKED OCSP Status.");
+        cert_status = V_OCSP_CERTSTATUS_REVOKED;
+      }
+      else if (getTestStatus(SF_TEST_OCSP_CERT_STATUS_UNKNOWN) == TEST_ENABLED)
+      {
+        failf(data, "Forced Failure - UNKNOWN OCSP Status");
+        cert_status = V_OCSP_CERTSTATUS_UNKNOWN;
+      }
+    }
+
+    switch(cert_status)
+    {
+      case V_OCSP_CERTSTATUS_GOOD:
+        result = CURLE_OK;
+        infof(data, "SSL certificate status: %s (%d)",
+              OCSP_cert_status_str(cert_status), cert_status);
+        goto end;
+
+      case V_OCSP_CERTSTATUS_REVOKED:
+        result = CERT_STATUS_REVOKED;
+        failf(data, "SSL certificate revocation reason: %s (%d)",
+              OCSP_crl_reason_str(crl_reason), crl_reason);
+        goto end;
+
+      case V_OCSP_CERTSTATUS_UNKNOWN:
+        result = CERT_STATUS_UNKNOWN;
+        infof(data, "SSL certificate status: %s (%d)",
+              OCSP_cert_status_str(cert_status), cert_status);
+        goto end;
+    }
+  }
+
+  /* Diagnostic: verify OCSP signer chain explicitly to capture detailed
+   * X509_STORE error codes before OCSP_basic_verify. */
+  {
+    X509 *signer_diag = NULL;
+    const STACK_OF(X509) *embedded = OCSP_resp_get0_certs(br);
+    if(OCSP_resp_get0_signer(br, &signer_diag, embedded) == 1 && signer_diag) {
+      X509_STORE_CTX *vctx = X509_STORE_CTX_new();
+      if(vctx && X509_STORE_CTX_init(vctx, st, signer_diag, ch) == 1) {
+        int vret = X509_verify_cert(vctx);
+        int verr = X509_STORE_CTX_get_error(vctx);
+        int vdepth = X509_STORE_CTX_get_error_depth(vctx);
+        infof(data, "OCSP diag: signer X509_verify_cert ret=%d err=%d depth=%d", vret, verr, vdepth);
+      }
+      if(vctx) X509_STORE_CTX_free(vctx);
+    } else {
+      infof(data, "OCSP diag: signer unavailable for explicit verification");
+    }
+  }
+
+end:
+  OCSP_BASICRESP_free(br);
+  return result;
+}
+
+struct curl_read_data
+{
+  char * read_data_ptr;
+  int size_left;
+};
+
+struct curl_memory_write
+{
+  char *memory_ptr;
+  size_t size;
+};
+
+static size_t
+write_callback(void *contents, size_t size, size_t nmemb, void *userp)
+{
+  size_t realsize = size * nmemb;
+  struct curl_memory_write *mem = (struct curl_memory_write *)userp;
+
+  mem->memory_ptr = realloc(mem->memory_ptr, mem->size + realsize + 1);
+
+  memcpy(&(mem->memory_ptr[mem->size]), contents, realsize);
+  mem->size += realsize;
+  mem->memory_ptr[mem->size] = 0; /* null terminated */
+
+  return realsize;
+}
+
+static char * getOCSPPostReqData(const char *hname, OCSP_CERTID *cid,
+                                 const char * ocsp_url, const char *ocsp_req,
+                                 struct Curl_easy *data)
+{
+    char *ret_data = NULL;
+    cJSON *hostname = sf_curl_cJSON_CreateString(hname);
+    cJSON *ocsp_request = sf_curl_cJSON_CreateString(ocsp_req);
+    cJSON *cert_id = sf_curl_cJSON_CreateString(encodeOCSPCertIDToBase64(cid, data));
+    cJSON *ocsp_responder_url = sf_curl_cJSON_CreateString(ocsp_url);
+
+    cJSON *ocsp_post = sf_curl_cJSON_CreateObject();
+
+    if (!ocsp_post)
+    {
+        goto end;
+    }
+
+    sf_curl_cJSON_AddItemToObject(ocsp_post, "cert_id", cert_id);
+    sf_curl_cJSON_AddItemToObject(ocsp_post, "ocsp_request", ocsp_request);
+    sf_curl_cJSON_AddItemToObject(ocsp_post, "ocsp_responder_url",ocsp_responder_url);
+    sf_curl_cJSON_AddItemToObject(ocsp_post, "hostname", hostname);
+    ret_data = sf_curl_cJSON_PrintUnformatted(ocsp_post);
+    end:
+    return ret_data;
+}
+
+static OCSP_RESPONSE * queryResponderUsingCurl(char *url, OCSP_CERTID *certid, char *hostname,
+                                               OCSP_REQUEST *req, struct Curl_easy *data,
+                                               SF_FAILOPEN_STATUS ocsp_fail_open,
+                                               SF_OTD *ocsp_log_data,
+                                               char *last_timeout_host)
+{
+  unsigned char *ocsp_req_der = NULL;
+  int len_ocsp_req_der = 0;
+  OCSP_RESPONSE * ocsp_response = NULL;
+  struct curl_memory_write ocsp_response_raw;
+  unsigned char *ocsp_response_der = NULL;
+  CURL *ocsp_curl = NULL;
+  char *ocsp_req_base64 = NULL;
+  size_t ocsp_req_base64_len = 0;
+  char *encoded_ocsp_req_base64 = NULL;
+  CURLcode result;
+  int use_ssl;
+  char *host = NULL, *port = NULL, *path = NULL;
+  char urlbuf[MAX_BUFFER_LENGTH];
+  int ocsp_retry_cnt = 0;
+
+  char *ocsp_post_data = NULL;
+  int ACTIVATE_SSD = checkSSDStatus();
+  char *cert_id_b64 = encodeOCSPCertIDToBase64(certid, data);
+  long sf_timeout = CA_OCSP_RESPONDER_CONNECTION_TIMEOUT;
+  int test_timeout;
+  char* test_ocsp_url = NULL;
+  int max_retry = CA_OCSP_RESPONDER_MAX_RETRY_FO;
+  int curl_success = 0;
+
+  ocsp_response_raw.memory_ptr = malloc(1);  /* will be grown as needed by the realloc above */
+  ocsp_response_raw.size = 0;
+  // Update OCSP Log Data
+  sf_otd_set_sfc_peer_host(hostname, ocsp_log_data);
+  sf_otd_set_certid(cert_id_b64, ocsp_log_data);
+
+  len_ocsp_req_der = i2d_OCSP_REQUEST(req, &ocsp_req_der);
+  if (len_ocsp_req_der<= 0 || ocsp_req_der == NULL)
+  {
+    failf(data, "Failed to encode ocsp request into DER format");
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_LOAD_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  result = curlx_base64_encode(
+      (char *)ocsp_req_der, (size_t)len_ocsp_req_der,
+      &ocsp_req_base64, &ocsp_req_base64_len);
+  if (result != CURLE_OK)
+  {
+    failf(data, "Failed to encode ocsp requst into base64 format");
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_ENCODE_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  sf_otd_set_ocsp_request(ocsp_req_base64, ocsp_log_data);
+
+  if (getTestStatus(SF_OCSP_TEST_MODE) == TEST_ENABLED)
+  {
+    printTestWarning(data);
+    if ((test_timeout = getTestStatus(SF_TEST_CA_OCSP_RESPONDER_CONNECTION_TIMEOUT)))
+    {
+      sf_timeout = test_timeout;
+    }
+    if ((test_ocsp_url = getenv("SF_TEST_OCSP_URL")) != NULL)
+    {
+      snprintf(urlbuf, sizeof(urlbuf),
+              "%s", test_ocsp_url);
+    }
+  }
+
+  OCSP_parse_url(url, &host, &port, &path, &use_ssl);
+  /* build a direct OCSP URL or OCSP Dynamic Cache Server URL */
+  if (getTestStatus(SF_OCSP_TEST_MODE) == TEST_DISABLED || test_ocsp_url == NULL)
+  {
+    if (!ACTIVATE_SSD)
+    {
+      result = encodeUrlData(ocsp_req_base64, ocsp_req_base64_len,
+                             &encoded_ocsp_req_base64, NULL);
+      if (result != CURLE_OK)
+      {
+        failf(data, "Failed to encode ocsp requst with URL safe");
+        sf_otd_set_event_sub_type(OCSP_RESPONSE_ENCODE_FAILURE, ocsp_log_data);
+        goto end;
+      }
+
+      // send the entire OCSP URL to the cache server
+      char full_url[MAX_BUFFER_LENGTH] = "";
+      strcpy(full_url, host ? host : "");
+
+      // default port numbers will not be added to the url
+      // (443 if the scheme is https, else 80)
+      if (port &&
+          atoi(port) > 0 &&
+          ((use_ssl && atoi(port) != 443) || (!use_ssl && atoi(port) != 80)))
+    {
+        strcat(full_url, ":");
+        strcat(full_url, port);
+    }
+
+      // path is guaranteed to begin with a / character
+      if (path && (strlen(path) > 1))
+      {
+          strcat(full_url, path);
+      }
+
+      snprintf(urlbuf, sizeof(urlbuf),
+               ocsp_cache_server_retry_url_pattern,
+               full_url,
+               encoded_ocsp_req_base64);
+    }
+    else
+    {
+      snprintf(urlbuf, sizeof(urlbuf), "%s",
+               ocsp_cache_server_retry_url_pattern);
+    }
+  }
+
+  OPENSSL_free(host);
+  OPENSSL_free(port);
+  OPENSSL_free(path);
+
+  infof(data, "OCSP fetch URL: %s", urlbuf);
+
+  int url_parse_result;
+
+  url_parse_result = OCSP_parse_url(
+      urlbuf, &host, &port, &path, &use_ssl);
+  if (!url_parse_result)
+  {
+    failf(data, "Invalid OCSP fetch URL: %s", urlbuf);
+    goto end;
+  }
+  if (strcasecmp(host, last_timeout_host) == 0)
+  {
+    // skip if we got timeout on the same host for previous certificate entry
+    goto end;
+  }
+
+  /* allocate another curl handle for ocsp checking */
+  ocsp_curl = curl_easy_init();
+
+  if (ocsp_curl)
+  {
+    curl_easy_setopt(ocsp_curl, CURLOPT_NOPROGRESS, 1L);
+    curl_easy_setopt(ocsp_curl, CURLOPT_NOSIGNAL, 1);
+    curl_easy_setopt(ocsp_curl, CURLOPT_TIMEOUT, sf_timeout);
+    curl_easy_setopt(ocsp_curl, CURLOPT_URL, urlbuf);
+    curl_easy_setopt(ocsp_curl, CURLOPT_ACCEPT_ENCODING, "");
+    curl_easy_setopt(ocsp_curl, CURLOPT_WRITEFUNCTION, write_callback);
+    curl_easy_setopt(ocsp_curl, CURLOPT_WRITEDATA, &ocsp_response_raw);
+    curl_easy_setopt(ocsp_curl, CURLOPT_VERBOSE, data && data->set.verbose ? 1L : 0L);
+    /* Debugfunction disabled for now to avoid missing symbol issues */
+
+    // copy proxy settings from original curl handle if it's set
+    curl_easy_setopt(ocsp_curl, CURLOPT_PROXY, data->set.str[STRING_PROXY]);
+    curl_easy_setopt(ocsp_curl, CURLOPT_PROXYPORT, data->set.proxyport);
+    if (data->set.str[STRING_PROXYUSERNAME] || data->set.str[STRING_PROXYPASSWORD])
+    {
+        curl_easy_setopt(ocsp_curl, CURLOPT_PROXYUSERNAME, data->set.str[STRING_PROXYUSERNAME]);
+        curl_easy_setopt(ocsp_curl, CURLOPT_PROXYPASSWORD, data->set.str[STRING_PROXYPASSWORD]);
+    }
+    curl_easy_setopt(ocsp_curl, CURLOPT_NOPROXY, data->set.str[STRING_NOPROXY]);
+
+    if (ACTIVATE_SSD)
+    {
+        curl_easy_setopt(ocsp_curl, CURLOPT_POST, 1L);
+        ocsp_post_data = getOCSPPostReqData(hostname, certid, url, ocsp_req_base64, data);
+        if (!ocsp_post_data)
+        {
+            goto end;
+        }
+        curl_easy_setopt(ocsp_curl, CURLOPT_POSTFIELDS, ocsp_post_data);
+    }
+
+    ocsp_retry_cnt = 0;
+
+    if (ocsp_fail_open == DISABLED)
+    {
+      max_retry = CA_OCSP_RESPONDER_MAX_RETRY_FC;
+    }
+
+    while(ocsp_retry_cnt < max_retry)
+    {
+      char error_msg[MAX_BUFFER_LENGTH];
+      CURLcode res = curl_easy_perform(ocsp_curl);
+
+      if (res != CURLE_OK)
+      {
+        failf(data, "OCSP checking curl_easy_perform() failed: %s",
+              curl_easy_strerror(res));
+        if (ocsp_retry_cnt == max_retry -1)
+        {
+          if (CURLE_OPERATION_TIMEDOUT == res)
+          {
+            failf(data, "Timeout reached when fetching OCSP response.");
+            strcpy(last_timeout_host, host);
+          }
+          snprintf(error_msg, OCSP_TELEMETRY_ERROR_MSG_MAX_LEN,
+                  "OCSP checking curl_easy_perform() failed: %s",
+                  curl_easy_strerror(res));
+          sf_otd_set_error_msg(error_msg, ocsp_log_data);
+          sf_otd_set_event_sub_type(OCSP_RESPONSE_FETCH_FAILURE, ocsp_log_data);
+        }
+        ocsp_retry_cnt++;
+      }
+      else if (res == CURLE_OK)
+      {
+        long response_code;
+        curl_easy_getinfo(ocsp_curl, CURLINFO_RESPONSE_CODE, &response_code);
+        if (response_code >= 200 && response_code < 300)
+        {
+          infof(data, "OCSP request returned with http status code 2XX");
+          curl_success = 1;
+          break;
+        }
+        else if (response_code < 200 || response_code >= 300)
+        {
+          failf(data, "OCSP request failed with non-200 level code: %ld",
+                response_code);
+
+          if (ocsp_retry_cnt == max_retry-1)
+          {
+            snprintf(error_msg, OCSP_TELEMETRY_ERROR_MSG_MAX_LEN,
+                "OCSP request failed with non 200 level code %li", response_code);
+            sf_otd_set_error_msg(error_msg, ocsp_log_data);
+            sf_otd_set_event_sub_type(OCSP_RESPONSE_FETCH_FAILURE, ocsp_log_data);
+          }
+          ocsp_retry_cnt++;
+        }
+      }
+    }
+  }
+
+  if (!curl_success)
+  {
+    goto end;
+  }
+
+  ocsp_response_der = (unsigned char*)ocsp_response_raw.memory_ptr;
+  ocsp_response = d2i_OCSP_RESPONSE(NULL,
+                                    (const unsigned char**)&ocsp_response_der,
+                                    (long)ocsp_response_raw.size);
+  if (ocsp_response == NULL)
+  {
+    failf(data, "Failed to decode ocsp response");
+    sf_otd_set_error_msg("Failed to decode ocsp response", ocsp_log_data);
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_DECODE_FAILURE, ocsp_log_data);
+  }
+
+end:
+  if (ocsp_req_base64) curl_free(ocsp_req_base64);
+  if (encoded_ocsp_req_base64) curl_free(encoded_ocsp_req_base64);
+  if (cert_id_b64) curl_free(cert_id_b64);
+  if (ocsp_req_der) OPENSSL_free(ocsp_req_der);
+  if (ocsp_curl) curl_easy_cleanup(ocsp_curl);
+  if (host) OPENSSL_free(host);
+  if (port) OPENSSL_free(port);
+  if (path) OPENSSL_free(path);
+
+  free(ocsp_response_raw.memory_ptr);
+
+  return ocsp_response;
+}
+
+/**
+ * Prepares OCSP request
+ * @param req OCSP_REQUEST
+ * @param certid OCSP_CERTID
+ * @param data curl handle
+ * @return 1 if success otherwise 0
+ */
+int prepareRequest(OCSP_REQUEST **req,
+                   OCSP_CERTID *certid,
+                   struct Curl_easy *data)
+{
+  if(!*req) *req = OCSP_REQUEST_new();
+  if(!*req)
+  {
+    failf(data, "Failed to allocate OCSP request");
+    goto err;
+  }
+  if(!OCSP_request_add0_id(*req, certid))
+  {
+    failf(data, "Failed to attach CertID to OCSP request");
+      goto err;
+  }
+  return 1;
+
+err:
+  return 0;
+}
+
+/**
+ * Update the cache entry with the CertID and Response
+ * @param certid OCSP_CERTID
+ * @param resp OCSP_RESPONSE
+ * @param data curl handle
+ */
+void updateOCSPResponseInMem(OCSP_CERTID *certid, OCSP_RESPONSE *resp,
+                             struct Curl_easy *data)
+{
+  char * cert_id_encode= NULL;
+  char * ocsp_response_encode = NULL;
+
+  unsigned long unix_time;
+
+  cJSON * cache_val_array = NULL;
+  cJSON *found = NULL;
+
+  /* encode OCSP CertID and OCSP Response */
+  cert_id_encode = encodeOCSPCertIDToBase64(certid, data);
+  if (cert_id_encode == NULL)
+  {
+    failf(data, "UpdateOCSPResponseInMem - cert id encode failed");
+    goto end;
+  }
+  ocsp_response_encode = encodeOCSPResponseToBase64(resp, data);
+  if (ocsp_response_encode == NULL)
+  {
+    failf(data, "UpdateOCSPResponseInMem - ocsp response encode failed %s", cert_id_encode);
+    goto end;
+  }
+
+  /* timestamp */
+  unix_time = (unsigned long)time(NULL);
+
+  /* write to mem cache */
+  cache_val_array = sf_curl_cJSON_CreateArray();
+  sf_curl_cJSON_AddItemToArray(cache_val_array, sf_curl_cJSON_CreateNumber((double) unix_time));
+  sf_curl_cJSON_AddItemToArray(cache_val_array, sf_curl_cJSON_CreateString(ocsp_response_encode));
+
+  _mutex_lock(&ocsp_response_cache_mutex);
+  if (ocsp_cache_root == NULL)
+  {
+    ocsp_cache_root = sf_curl_cJSON_CreateObject();
+  }
+  found = getCacheEntry(certid, data);
+  if (found != NULL)
+  {
+    /* delete existing entry first if exists. */
+    sf_curl_cJSON_DeleteItemFromObject(ocsp_cache_root, found->string);
+  }
+  sf_curl_cJSON_AddItemToObject(ocsp_cache_root, cert_id_encode, cache_val_array);
+  _mutex_unlock(&ocsp_response_cache_mutex);
+end:
+  if (cert_id_encode) curl_free(cert_id_encode);
+  if (ocsp_response_encode) curl_free(ocsp_response_encode);
+}
+
+/**
+ * Encode OCSP CertID to Base 64 string
+ *
+ * @param certid OCSP_CERTID
+ * @param data curl handle
+ * @return base64 string
+ */
+char* encodeOCSPCertIDToBase64(OCSP_CERTID *certid, struct Curl_easy *data)
+{
+  int len;
+  char* ret = NULL;
+  unsigned char *der_buf = NULL;
+  size_t encode_len = 0;
+  CURLcode result;
+
+  len = i2d_OCSP_CERTID(certid, &der_buf);
+  if (len <= 0 || der_buf == NULL)
+  {
+    infof(data, "Failed to encode OCSP CertId");
+    goto end;
+  }
+  result = curlx_base64_encode((char *)der_buf, (size_t)len,
+                              &ret, &encode_len);
+  if (result != CURLE_OK)
+  {
+    infof(data, "Failed to encode OCSP CertId to base64: %s",
+          curl_easy_strerror(result));
+  }
+end:
+  if (der_buf) OPENSSL_free(der_buf);
+  return ret;
+}
+
+/**
+ * Encode OCSP Request to Base 64 string
+ * @param reqp OCSP_REQUEST
+ * @param data curl handle
+ * @return base64 string
+ */
+char *encodeOCSPRequestToBase64(OCSP_REQUEST *reqp, struct Curl_easy *data)
+{
+  int len;
+  char* ret = NULL;
+  unsigned char *der_buf = NULL;
+  size_t encode_len = 0;
+  CURLcode result;
+
+  len = i2d_OCSP_REQUEST(reqp, &der_buf);
+  if (len <= 0 || der_buf == NULL)
+  {
+    infof(data, "Failed to encode OCSP response");
+    goto end;
+  }
+
+  result = curlx_base64_encode((char *)der_buf, (size_t)len,
+                              &ret, &encode_len);
+  if (result != CURLE_OK)
+  {
+    infof(data, "Failed to encode OCSP response to base64: %s",
+          curl_easy_strerror(result));
+    goto end;
+  }
+end:
+  if (der_buf) OPENSSL_free(der_buf);
+  return ret;
+}
+
+/**
+ * Encode OCSP Response to Base 64 string
+ *
+ * @param resp OCSP_RESPONSE
+ * @param data curl handle
+ * @return base64 string
+ */
+char *encodeOCSPResponseToBase64(OCSP_RESPONSE* resp, struct Curl_easy *data)
+{
+  int len;
+  char* ret = NULL;
+  unsigned char *der_buf = NULL;
+  size_t encode_len = 0;
+  CURLcode result;
+
+  len = i2d_OCSP_RESPONSE(resp, &der_buf);
+  if (len <= 0 || der_buf == NULL)
+  {
+    infof(data, "Failed to encode OCSP response");
+    goto end;
+  }
+
+  result = curlx_base64_encode((char *)der_buf, (size_t)len,
+                              &ret, &encode_len);
+  if (result != CURLE_OK)
+  {
+    infof(data, "Failed to encode OCSP response to base64: %s",
+          curl_easy_strerror(result));
+    goto end;
+  }
+end:
+  if (der_buf) OPENSSL_free(der_buf);
+  return ret;
+}
+
+/**
+ * Decoede OCSP CertID from Base 64 string
+ * @param src a base64 string
+ * @param data curl handle
+ * @return OCSP_CERTID
+ */
+OCSP_CERTID* decodeOCSPCertIDFromBase64(char* src, struct Curl_easy *data)
+{
+  unsigned char *ocsp_certid_der = NULL;
+  unsigned char *ocsp_certid_der_org = NULL;
+  size_t ocs_certid_der_len;
+  OCSP_CERTID *target_certid = NULL;
+  CURLcode result;
+  if (src == NULL)
+  {
+    infof(data, "Base64 input is NULL for decoding OCSP CertID");
+    return NULL;
+  }
+
+  result = curlx_base64_decode(src,
+                              &ocsp_certid_der, &ocs_certid_der_len);
+  if (result != CURLE_OK)
+  {
+    infof(data, "Failed to decode OCSP CertID in the cache. Ignored: %s",
+          curl_easy_strerror(result));
+    return NULL;
+  }
+  /* keep the original pointer as it will be updated in d2i function */
+  ocsp_certid_der_org = ocsp_certid_der;
+
+  target_certid = d2i_OCSP_CERTID(
+    NULL, (const unsigned char**)&ocsp_certid_der, (long)ocs_certid_der_len);
+
+  curl_free(ocsp_certid_der_org);
+
+  if (target_certid == NULL)
+  {
+    infof(data, "Failed to decode OCSP CertID.");
+    return NULL;
+  }
+  return target_certid;
+}
+
+/**
+ * Decode OCSP Response from Base 64 string
+ * @param src a base64 string
+ * @param data curl handle
+ * @return OCSP_RESPONSE or NULL
+ */
+OCSP_RESPONSE * decodeOCSPResponseFromBase64(char* src, struct Curl_easy *data)
+{
+  OCSP_RESPONSE *resp = NULL;
+  unsigned char *ocsp_response_der;
+  unsigned char *ocsp_response_der_org;
+  size_t ocsp_response_der_len;
+  CURLcode result;
+
+  if (src == NULL)
+  {
+    infof(data, "Base64 input is NULL for decoding OCSP Response");
+    return NULL;
+  }
+  result = curlx_base64_decode(src,
+                              &ocsp_response_der, &ocsp_response_der_len);
+  if (result)
+  {
+    infof(data, "Failed to decode OCSP response from base64 string: %s",
+          curl_easy_strerror(result));
+    return NULL;
+  }
+  /* keep the original pointer as it will be updated in d2i function */
+  ocsp_response_der_org = ocsp_response_der;
+
+  resp = d2i_OCSP_RESPONSE(NULL, (const unsigned char **) &ocsp_response_der,
+                           (long) ocsp_response_der_len);
+  curl_free(ocsp_response_der_org);
+  if (resp == NULL)
+  {
+    infof(data, "Failed to decode OCSP response cache from der format");
+    return NULL;
+  }
+  return resp;
+}
+
+
+
+/**
+ * Validate OCSP Response time validity
+ */
+
+static SF_OCSP_STATUS checkResponseTimeValidity(OCSP_RESPONSE *resp, struct Curl_easy *data, SF_OTD *ocsp_log_data)
+{
+    int i;
+    SF_OCSP_STATUS ret_val = INVALID;
+    OCSP_BASICRESP *br = NULL;
+
+    br = OCSP_response_get1_basic(resp);
+    if (br == NULL)
+    {
+        failf(data, "Failed to get OCSP response basic from cache");
+        sf_otd_set_event_sub_type(OCSP_RESPONSE_CACHE_ENTRY_LOAD_FAILED, ocsp_log_data);
+        goto end;
+    }
+
+    for (i = 0; i < OCSP_resp_count(br); i++)
+    {
+        int crl_reason;
+        int psec, pday;
+        long skewInSec = 900L;
+
+        OCSP_SINGLERESP *single = NULL;
+
+        ASN1_GENERALIZEDTIME *rev, *thisupd, *nextupd;
+
+        single = OCSP_resp_get0(br, i);
+        if(!single)
+            continue;
+
+        OCSP_single_get0_status(single, &crl_reason, &rev,
+                                &thisupd, &nextupd);
+
+
+        if (ASN1_TIME_diff(&pday, &psec, thisupd, nextupd))
+        {
+            /*
+             * Allow leeway = 1% of the difference of OCSP response validity
+             * validity = 1% (actual validity of OCSP Response)
+             */
+            long validity = (pday*24*60*60 + psec)/100;
+            skewInSec = validity > skewInSec ? validity : skewInSec;
+            infof(data, "Diff between thisupd and nextupd "
+            "day: %d, sec: %d, Tolerant skew: %ld", pday, psec,
+            skewInSec);
+        }
+        else
+        {
+            failf(data, "Invalid structure of ASN1_GENERALIZEDTIME");
+            goto end;
+        }
+        /*
+         * Consider the OCSP response' time range to be valid if it lies
+         * in the following range - [thisupd-validity, nextupd+validity]
+         */
+        if(!OCSP_check_validity(thisupd, nextupd, skewInSec, -1L))
+        {
+          failf(data, "OCSP response has expired");
+          sf_otd_set_event_sub_type(OCSP_RESPONSE_FROM_CACHE_EXPIRED, ocsp_log_data);
+          goto end;
+        }
+    }
+
+    ret_val = VALID;
+
+    end:
+    OCSP_BASICRESP_free(br);
+    return ret_val;
+}
+
+
+/**
+ * Extract OCSP Response from the cache value.
+ *
+ * Must mutex protected as it may delete the existing element if the last
+ * query time is older than 24 hours.
+ *
+ * @param cache_value a cache value to update
+ * @param data curl handle
+ * @return OCSP_RESPONSE
+ */
+OCSP_RESPONSE* extractOCSPRespFromValue(cJSON *cache_value, struct Curl_easy *data,
+                                        SF_OTD *ocsp_log_data)
+{
+  long last_query_time_l = 0L;
+  cJSON * resp_bas64_j = NULL;
+  cJSON * last_query_time = NULL;
+  OCSP_RESPONSE *resp = NULL;
+
+  if (cache_value == NULL || !sf_curl_cJSON_IsArray(cache_value))
+  {
+    infof(data, "OCSP Cache value is invalid");
+    goto end;
+  }
+
+  /* First item is the timestamp when the cache entry was created. */
+  last_query_time = sf_curl_cJSON_GetArrayItem(cache_value, 0);
+  if (!sf_curl_cJSON_IsNumber(last_query_time))
+  {
+    infof(data, "OCSP Cache Last query time is invalid");
+    sf_curl_cJSON_DeleteItemFromObjectCaseSensitive(ocsp_cache_root,
+                                            cache_value->string);
+    goto end;
+  }
+
+  last_query_time_l = (long)last_query_time->valuedouble;
+
+  /* valid for 120 hours */
+  if ((unsigned long)time(NULL) - last_query_time_l >= 24*60*60*5)
+  {
+    infof(data, "OCSP Response Cache Expired");
+    goto end;
+  }
+
+  /* Second item is the actual OCSP response data */
+  resp_bas64_j = sf_curl_cJSON_GetArrayItem(cache_value, 1);
+  if (!sf_curl_cJSON_IsString(resp_bas64_j) || resp_bas64_j->valuestring == NULL)
+  {
+    infof(data, "OCSP Response cache is invalid. Deleting it from the cache.");
+    sf_curl_cJSON_DeleteItemFromObjectCaseSensitive(ocsp_cache_root,
+                                            cache_value->string);
+    goto end;
+  }
+
+  /* decode OCSP Response from base64 string */
+  resp = decodeOCSPResponseFromBase64(resp_bas64_j->valuestring, data);
+  if (checkResponseTimeValidity(resp, data, ocsp_log_data) == INVALID)
+  {
+      resp = NULL;
+  }
+  end:
+  return resp;
+}
+
+/**
+ * Find OCSP Response in memory cache.
+ * @param certid OCSP CertID
+ * @param data curl handle
+ * @return OCSP Response if success otherwise NULL
+ */
+OCSP_RESPONSE * findOCSPRespInMem(OCSP_CERTID *certid, struct Curl_easy *data, SF_OTD *ocsp_log_data)
+{
+  /* calculate certid */
+  OCSP_RESPONSE *resp = NULL;
+  cJSON *found = NULL;
+
+  _mutex_lock(&ocsp_response_cache_mutex);
+  found = getCacheEntry(certid, data);
+  if (!found)
+  {
+    infof(data, "OCSP Response not found in the cache");
+    goto end;
+  }
+  resp = extractOCSPRespFromValue(found, data, ocsp_log_data);
+  if (resp)
+  {
+    /* NOTE encode to base64 only for logging */
+    char* cert_id_encode = encodeOCSPCertIDToBase64(certid, data);
+    infof(data, "OCSP Response Cache found!!!: %s", cert_id_encode);
+    if (cert_id_encode) curl_free(cert_id_encode);
+  }
+end:
+  _mutex_unlock(&ocsp_response_cache_mutex);
+  return resp;
+}
+
+/**
+ * Get the cache entry for the CertID.
+ *
+ * @param certid OCSP CertID
+ * @param data curl handle
+ * @return cJSON cache entry if found otherwise NULL
+ */
+cJSON *getCacheEntry(OCSP_CERTID* certid, struct Curl_easy *data)
+{
+  cJSON *ret = NULL;
+  cJSON *element_pointer = NULL;
+
+  if (ocsp_cache_root == NULL)
+  {
+    ocsp_cache_root = sf_curl_cJSON_CreateObject();
+  }
+
+  sf_curl_cJSON_ArrayForEach(element_pointer, ocsp_cache_root)
+  {
+    int cmp = 0;
+    OCSP_CERTID *target_certid = decodeOCSPCertIDFromBase64(
+      element_pointer->string, data);
+
+    if (target_certid == NULL)
+    {
+      infof(data, "Failed to decode OCSP CertID in the cache.");
+      continue;
+    }
+    cmp = OCSP_id_cmp(target_certid, certid);
+    OCSP_CERTID_free(target_certid);
+    if (cmp == 0)
+    {
+      ret = element_pointer;
+      break;
+    }
+  }
+  return ret;
+}
+
+/**
+ * Delete a Cache entry for Cert ID
+ * @param certid OCSP_CERTID
+ * @param data curl handle
+ */
+void deleteCacheEntry(OCSP_CERTID* certid, struct Curl_easy *data)
+{
+  cJSON *found = NULL;
+
+  _mutex_lock(&ocsp_response_cache_mutex);
+  found = getCacheEntry(certid, data);
+  if (found)
+  {
+    sf_curl_cJSON_DeleteItemFromObject(ocsp_cache_root, found->string);
+  }
+  _mutex_unlock(&ocsp_response_cache_mutex);
+}
+
+/**
+ * Update OCSP cache with the cJSON data
+ * @param tmp_cache a cJSON data
+ * @param data curl handle
+ */
+void updateCacheWithBulkEntries(cJSON* tmp_cache, struct Curl_easy *data)
+{
+  cJSON *element_pointer = NULL;
+  cJSON *found = NULL;
+  cJSON *new_value = NULL;
+
+  /* Detect the existing elements */
+  sf_curl_cJSON_ArrayForEach(element_pointer, tmp_cache)
+  {
+    OCSP_CERTID *cert_id = decodeOCSPCertIDFromBase64(
+      element_pointer->string, data);
+    if (cert_id == NULL)
+    {
+      infof(data, "CertID is NULL");
+      continue;
+    }
+    found = getCacheEntry(cert_id, data);
+    OCSP_CERTID_free(cert_id);
+    new_value = sf_curl_cJSON_Duplicate(element_pointer, 1);
+    if (found != NULL)
+    {
+      sf_curl_cJSON_DeleteItemFromObject(ocsp_cache_root, found->string);
+    }
+    sf_curl_cJSON_AddItemToObject(ocsp_cache_root, element_pointer->string, new_value);
+  }
+}
+
+/**
+ * Download a OCSP cache content from OCSP cache server.
+ * @param data curl handle
+ */
+void downloadOCSPCache(struct Curl_easy *data, SF_OTD *ocsp_log_data, char *last_timeout_host)
+{
+  struct curl_memory_write ocsp_response_cache_json_mem;
+  CURL *curlh = NULL;
+  struct curl_slist *headers = NULL;
+  cJSON *tmp_cache = NULL;
+  CURLcode res = CURLE_OK;
+
+  int sf_timeout = OCSP_CACHE_SERVER_CONNECTION_TIMEOUT;
+  int test_timeout = OCSP_CACHE_SERVER_CONNECTION_TIMEOUT;
+
+  ocsp_response_cache_json_mem.memory_ptr = malloc(1);  /* will be grown as needed by the realloc above */
+  ocsp_response_cache_json_mem.size = 0;
+
+  int use_ssl;
+  int url_parse_result;
+  char *host = NULL, *port = NULL, *path = NULL;
+
+  url_parse_result = OCSP_parse_url(
+      ocsp_cache_server_url, &host, &port, &path, &use_ssl);
+  if (!url_parse_result)
+  {
+    failf(data, "Invalid OCSP cache server URL: %s", ocsp_cache_server_url);
+    goto end;
+  }
+  if (strcasecmp(host, last_timeout_host) == 0)
+  {
+    // skip if we got timeout on the same host for previous certificate entry
+    goto end;
+  }
+
+  /* allocate another curl handle for ocsp checking */
+  curlh = curl_easy_init();
+  if (!curlh)
+  {
+    failf(data, "Failed to initialize curl to download OCSP cache.");
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_CURL_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  headers = curl_slist_append(headers, "Content-Type:application/json");
+
+  if (getTestStatus(SF_OCSP_TEST_MODE))
+  {
+    printTestWarning(data);
+    if ((test_timeout = getTestStatus(SF_TEST_OCSP_CACHE_SERVER_CONNECTION_TIMEOUT)))
+    {
+      failf(data, "Forced Failure - REVOKED OCSP Status.");
+      sf_timeout = test_timeout;
+    }
+  }
+
+  curl_easy_setopt(curlh, CURLOPT_NOPROGRESS, 1L);
+  curl_easy_setopt(curlh, CURLOPT_NOSIGNAL, 1);
+  curl_easy_setopt(curlh, CURLOPT_TIMEOUT, sf_timeout);
+  curl_easy_setopt(curlh, CURLOPT_URL, ocsp_cache_server_url);
+  /* empty means use all of builtin supported encodings */
+  curl_easy_setopt(curlh, CURLOPT_ACCEPT_ENCODING, "");
+  curl_easy_setopt(curlh, CURLOPT_HTTPHEADER, headers);
+  curl_easy_setopt(curlh, CURLOPT_WRITEFUNCTION, write_callback);
+  curl_easy_setopt(curlh, CURLOPT_WRITEDATA, &ocsp_response_cache_json_mem);
+
+  // copy proxy settings from original curl handle if it's set
+  curl_easy_setopt(curlh, CURLOPT_PROXY, data->set.str[STRING_PROXY]);
+  curl_easy_setopt(curlh, CURLOPT_PROXYPORT, data->set.proxyport);
+  if (data->set.str[STRING_PROXYUSERNAME] || data->set.str[STRING_PROXYPASSWORD])
+  {
+      curl_easy_setopt(curlh, CURLOPT_PROXYUSERNAME, data->set.str[STRING_PROXYUSERNAME]);
+      curl_easy_setopt(curlh, CURLOPT_PROXYPASSWORD, data->set.str[STRING_PROXYPASSWORD]);
+  }
+  curl_easy_setopt(curlh, CURLOPT_NOPROXY, data->set.str[STRING_NOPROXY]);
+
+  res = CURLE_OK;
+
+  res = curl_easy_perform(curlh);
+  if (res == CURLE_OK)
+  {
+    long response_code;
+    curl_easy_getinfo(curlh, CURLINFO_RESPONSE_CODE, &response_code);
+    if (response_code >= 200 && response_code < 300)
+    {
+      /* Success */
+      infof(data, "OCSP Cache Download request returned with http status code 2XX");
+      infof(data, "Successfully downloaded OCSP Cache.");
+    }
+    else if (response_code < 200 || response_code >= 300 )
+    {
+      failf(data, "OCSP cache download request failed with non-200 level code: %ld, OCSP Cache Could not be downloaded",
+            response_code);
+      sf_otd_set_event_sub_type(OCSP_RESPONSE_CACHE_DOWNLOAD_FAILED, ocsp_log_data);
+      goto end;
+    }
+  }
+  else
+  {
+    failf(data, "CURL Response code is not CURLE_OK.");
+    if (CURLE_OPERATION_TIMEDOUT == res)
+    {
+      failf(data, "Timeout reached when downloading OCSP cache.");
+      strcpy(last_timeout_host, host);
+    }
+    sf_otd_set_event_sub_type(OCSP_RESPONSE_CURL_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  _mutex_lock(&ocsp_response_cache_mutex);
+  if (ocsp_cache_root == NULL)
+  {
+    ocsp_cache_root = sf_curl_cJSON_CreateObject();
+  }
+  tmp_cache = sf_curl_cJSON_Parse(ocsp_response_cache_json_mem.memory_ptr);
+
+  /* update OCSP cache with the downloaded cache */
+  updateCacheWithBulkEntries(tmp_cache, data);
+  infof(data, "Number of cache entries: %d",
+        sf_curl_cJSON_GetArraySize(ocsp_cache_root));
+
+  _mutex_unlock(&ocsp_response_cache_mutex);
+end:
+  if (tmp_cache) sf_curl_cJSON_Delete(tmp_cache);
+  if (curlh) curl_easy_cleanup(curlh);
+  if (headers) curl_slist_free_all(headers);
+  if (host) OPENSSL_free(host);
+  if (port) OPENSSL_free(port);
+  if (path) OPENSSL_free(path);
+
+  free(ocsp_response_cache_json_mem.memory_ptr);
+}
+
+/**
+ * Find OCSP Response in local cache first. If not found, go to OCSP server to
+ * get the response.
+
+ * @param cert subject certificate
+ * @param issuer issuer certificate
+ * @param data curl connection data
+ * @return OCSP response
+ */
+OCSP_RESPONSE * getOCSPResponse(X509 *cert, X509 *issuer,
+                                struct connectdata *conn,
+								struct Curl_easy *data,
+                                SF_FAILOPEN_STATUS ocsp_fail_open,
+                                SF_OTD *ocsp_log_data,
+                                char *last_timeout_host)
+{
+  int i;
+  bool ocsp_url_missing = true;
+  bool ocsp_url_invalid = true;
+  OCSP_RESPONSE *resp = NULL;
+  OCSP_REQUEST *req = NULL;
+  OCSP_CERTID *certid = NULL;
+  STACK_OF(OPENSSL_STRING) *ocsp_list = NULL;
+  const EVP_MD *cert_id_md = EVP_sha1();
+
+  /* get certid first */
+  certid = OCSP_cert_to_id(cert_id_md, cert, issuer);
+  resp = findOCSPRespInMem(certid, data, ocsp_log_data);
+  if (resp != NULL)
+  {
+    sf_otd_set_cache_hit(1, ocsp_log_data);
+    infof(data, "OCSP Entry found in cache");
+    goto end; /* found OCSP response in cache */
+  }
+
+  if (ocsp_cache_server_enabled)
+  {
+    sf_otd_set_cache_enabled(1, ocsp_log_data);
+    /* download OCSP Cache from the server*/
+    downloadOCSPCache(data, ocsp_log_data, last_timeout_host);
+
+    /* try hitting cache again */
+    resp = findOCSPRespInMem(certid, data, ocsp_log_data);
+    if (resp != NULL)
+    {
+      sf_otd_set_cache_hit(1, ocsp_log_data);
+      infof(data, "OCSP entry found in cache after fresh cache download");
+      goto end; /* found OCSP response in cache */
+    }
+  }
+  else
+  {
+    sf_otd_set_cache_enabled(0, ocsp_log_data);
+    infof(data, "OCSP Cache Server is disabled");
+    ocsp_log_data->cache_enabled = 0;
+  }
+
+  sf_otd_set_cache_hit(0, ocsp_log_data);
+  if (!prepareRequest(&req, certid, data))
+  {
+    sf_otd_set_event_sub_type(OCSP_REQUEST_CREATION_FAILURE, ocsp_log_data);
+    goto end; /* failed to prepare request */
+  }
+
+  /* loop through OCSP urls */
+  ocsp_list = X509_get1_ocsp(cert);
+  for (i = 0; i < sk_OPENSSL_STRING_num(ocsp_list); i++)
+  {
+    int use_ssl;
+    int url_parse_result;
+    char *host = NULL, *port = NULL, *path = NULL;
+
+    char *ocsp_url = sk_OPENSSL_STRING_value(ocsp_list, i);
+    if (ocsp_url == NULL)
+    {
+      /* Try the next OCSP Server in ocsp_list, if present. */
+      continue;
+    }
+    ocsp_url_missing = false;
+    infof(data, "OCSP Validation URL: %s", ocsp_url);
+    strncpy(ocsp_log_data->ocsp_responder_url, ocsp_url, sizeof(ocsp_log_data->ocsp_responder_url));
+    url_parse_result = OCSP_parse_url(
+        ocsp_url, &host, &port, &path, &use_ssl);
+    if (!url_parse_result)
+    {
+      failf(data, "Invalid OCSP Validation URL: %s", ocsp_url);
+      /* try the next OCSP server if available. */
+      continue;
+    }
+
+    ocsp_url_invalid = false;
+    resp = queryResponderUsingCurl(ocsp_url, certid, conn->host.name, req, data, ocsp_fail_open, ocsp_log_data, last_timeout_host);
+    /* update local cache */
+    OPENSSL_free(host);
+    OPENSSL_free(path);
+    OPENSSL_free(port);
+
+    if (resp) {
+      updateOCSPResponseInMem(certid, resp, data);
+      break; /* good if any OCSP server works */
+    } else {
+      /* try next OCSP URL in the list */
+      continue;
+    }
+  }
+
+  if((ocsp_url_missing || ocsp_url_invalid) && (ocsp_fail_open == DISABLED))
+  {
+    failf(data, "OCSP Validation URL is not present or invalid.");
+    sf_otd_set_event_sub_type(OCSP_URL_MISSING_OR_INVALID, ocsp_log_data);
+  }
+
+end:
+  if (ocsp_list) X509_email_free(ocsp_list);
+  /* when ocsp certid is found in mem, which means that no OCSP_REQUEST object
+     will be created, so needs to explicitly freed certid. Otherwise, certid
+     will be freed along with the deallocation of OCSP_REQUEST object */
+  if (!req && certid) OCSP_CERTID_free(certid);
+  /* https://www.openssl.org/docs/man1.1.0/crypto/OCSP_request_add0_id.html
+   * certid must NOT be freed here */
+  if (req) OCSP_REQUEST_free(req);
+  return resp;
+}
+
+
+static void printOCSPFailOpenWarning(SF_OTD *ocsp_log, struct Curl_easy *data, bool oob_enable)
+{
+  char *ocsp_log_data = NULL;
+  ocsp_log_data = generateOCSPTelemetryData(ocsp_log);
+  infof(data, "OCSP responder didn't respond correctly. Assuming certificate is not revoked."
+              " Details:%s", ocsp_log_data);
+}
+
+static char * generateOCSPTelemetryData(SF_OTD *ocsp_log)
+{
+  char *oobevent;
+  if (!ocsp_log) {
+    return NULL;
+  }
+  setOOBeventdata(OOBEVENTNAME, "OCSPException", 0);
+  setOOBeventdata(URGENCY, NULL, 1);
+  oobevent = prepareOOBevent(ocsp_log);
+  clearOSCPLogData(ocsp_log);
+  return oobevent;
+}
+
+static void clearOSCPLogData(SF_OTD *ocsp_log)
+{
+  if (!ocsp_log) {
+    return;
+  }
+  ocsp_log->event_type[0] = '\0';
+  ocsp_log->event_sub_type[0] = '\0';
+  ocsp_log->sfc_peer_host[0] = '\0';
+  ocsp_log->cert_id[0] = '\0';
+  ocsp_log->ocsp_req_b64[0] = '\0';
+  ocsp_log->ocsp_responder_url[0] = '\0';
+  ocsp_log->error_msg[0] = '\0';
+}
+/**
+ * Check one certificate
+ * @param cert subject certificate
+ * @param issuer issuer certificate
+ * @param ch certificate chain
+ * @param st CA certificates
+ * @param conn curl connection data
+ * @return curl return code
+ */
+CURLcode checkOneCert(X509 *cert, X509 *issuer,
+                      STACK_OF(X509) *ch, X509_STORE *st,
+                      SF_FAILOPEN_STATUS ocsp_fail_open,
+                      struct connectdata *conn,
+					  struct Curl_easy *data,
+                      SF_OTD *ocsp_log_data,
+                      bool oob_enable,
+                      char *last_timeout_host)
+{
+  CURLcode result;
+  SF_CERT_STATUS sf_cert_status = CERT_STATUS_INVALID;
+#define MAX_CERT_NAME_LEN 100
+  char X509_cert_name[MAX_CERT_NAME_LEN + 1];
+  int retry_count = 0;
+  OCSP_RESPONSE *resp = NULL;
+  const EVP_MD *cert_id_md = EVP_sha1();
+
+  char *ocsp_log_str = NULL;
+
+
+  while(retry_count < MAX_RETRY)
+  {
+    OCSP_CERTID *certid = NULL;
+    int ocsp_status = 0;
+    resp = getOCSPResponse(cert, issuer, conn, data, ocsp_fail_open, ocsp_log_data, last_timeout_host);
+    infof(data, "Starting checking cert for %s...",
+          X509_NAME_oneline(X509_get_subject_name(cert), X509_cert_name,
+                            MAX_CERT_NAME_LEN));
+    if (!resp)
+    {
+      failf(data, "Unable to get OCSP response");
+      if (retry_count == MAX_RETRY - 1)
+      {
+        sf_otd_set_event_sub_type(OCSP_RESPONSE_FETCH_FAILURE, ocsp_log_data);
+      }
+      sf_cert_status = CERT_STATUS_INVALID;
+      ++retry_count;
+      continue;
+    }
+
+    ocsp_status = OCSP_response_status(resp);
+    if (ocsp_status != OCSP_RESPONSE_STATUS_SUCCESSFUL)
+    {
+      failf(data, "Invalid OCSP response status: %s (%d)",
+            OCSP_response_status_str(ocsp_status), ocsp_status);
+      if (retry_count ==  MAX_RETRY - 1)
+      {
+        sf_otd_set_event_sub_type(OCSP_RESPONSE_STATUS_UNSUCCESSFUL, ocsp_log_data);
+      }
+      sf_cert_status = CERT_STATUS_UNAVAILABLE;
+      if (resp) OCSP_RESPONSE_free(resp);
+      resp = NULL;
+      ++retry_count;
+      continue;
+    }
+
+    sf_cert_status = checkResponse(resp, ch, st, data, ocsp_log_data);
+
+    if (sf_cert_status == CERT_STATUS_GOOD)
+    {
+      result = CURLE_OK;
+      break;
+    }
+    else if (sf_cert_status == CERT_STATUS_REVOKED)
+    {
+      sf_otd_set_event_sub_type(OCSP_RESPONSE_CERT_STATUS_REVOKED, ocsp_log_data);
+      break;
+    }
+
+    /* delete the cache if the validation failed. */
+    certid = OCSP_cert_to_id(cert_id_md, cert, issuer);
+    deleteCacheEntry(certid, data);
+    OCSP_CERTID_free(certid);
+
+    /* retry */
+    ++retry_count;
+  }
+
+  if (sf_cert_status != CERT_STATUS_GOOD)
+  {
+    /* delete the cache if OCSP revocation check fails */
+    OCSP_CERTID *certid = NULL;
+
+    /* remove the entry from cache */
+    certid = OCSP_cert_to_id(cert_id_md, cert, issuer);
+    deleteCacheEntry(certid, data);
+    OCSP_CERTID_free(certid);
+
+    if (sf_cert_status == CERT_STATUS_UNAVAILABLE)
+    {
+      sf_otd_set_error_msg("OCSP Response Unavailable", ocsp_log_data);
+      sf_otd_set_event_type("RevocationCheckFailure", ocsp_log_data);
+      sf_otd_set_event_sub_type(OCSP_RESPONSE_CERT_STATUS_UNAVAILABLE, ocsp_log_data);
+    }
+    else if (sf_cert_status == CERT_STATUS_UNKNOWN)
+    {
+      sf_otd_set_error_msg("OCSP Response Unknown", ocsp_log_data);
+      sf_otd_set_event_type("RevocationCheckFailure", ocsp_log_data);
+      sf_otd_set_event_sub_type(OCSP_RESPONSE_CERT_STATUS_UNKNOWN, ocsp_log_data);
+    }
+    else if (sf_cert_status == CERT_STATUS_INVALID)
+    {
+      sf_otd_set_error_msg("OCSP Response is Invalid", ocsp_log_data);
+      sf_otd_set_event_type("RevocationCheckFailure", ocsp_log_data);
+      sf_otd_set_event_sub_type(OCSP_RESPONSE_CERT_STATUS_INVALID, ocsp_log_data);
+    }
+
+    /* Diagnostics before deciding fail-open/close */
+    {
+      char subj[256];
+      char iss[256];
+      subj[0] = '\0';
+      iss[0] = '\0';
+      X509_NAME_oneline(X509_get_subject_name(cert), subj, (int)sizeof(subj));
+      X509_NAME_oneline(X509_get_subject_name(issuer), iss, (int)sizeof(iss));
+      infof(data, "OCSP diag: sf_status=%d fail_open=%d end_entity=%s issuer=%s", (int)sf_cert_status, (int)ocsp_fail_open, subj, iss);
+      if(ch) {
+        int c = sk_X509_num(ch);
+        int i;
+        for(i = 0; i < c && i < 6; ++i) {
+          X509 *cx = sk_X509_value(ch, i);
+          char line[256];
+          line[0] = '\0';
+          X509_NAME_oneline(X509_get_subject_name(cx), line, (int)sizeof(line));
+          infof(data, "OCSP diag: chain[%d] subject=%s", i, line);
+        }
+      }
+    }
+
+    if (ocsp_fail_open == ENABLED && sf_cert_status != CERT_STATUS_REVOKED)
+    {
+      sf_otd_set_fail_open_mode(1, ocsp_log_data);
+      printOCSPFailOpenWarning(ocsp_log_data, data, oob_enable);
+      result = CURLE_OK;
+    }
+    else
+    {
+      sf_otd_set_fail_open_mode(0, ocsp_log_data);
+      result = CURLE_SSL_INVALIDCERTSTATUS;
+      ocsp_log_str = generateOCSPTelemetryData(ocsp_log_data);
+      if (ocsp_log_str)
+      {
+        if (oob_enable)
+        {
+          sendOOBevent(ocsp_log_str);
+        }
+        // multiple line logging is not allowed in curl
+        // infof(data, ocsp_log_str);
+        if(ocsp_log_str) sf_curl_cJSON_free(ocsp_log_str);
+      }
+    }
+  }
+  if (resp) OCSP_RESPONSE_free(resp);
+  return result;
+}
+
+/**
+ * Make a directory if not exists
+ * @param dir a directory to create
+ * @param data curl handle
+ * @return directory name if success otherwise NULL
+ */
+char* mkdirIfNotExists(char* dir, struct Curl_easy *data)
+{
+#ifdef _WIN32
+  int result = _mkdir(dir);
+#else
+  int result = mkdir(dir, 0755);
+#endif
+  if (result != 0)
+  {
+    if (errno != EEXIST)
+    {
+      failf(data, "Failed to create %s directory. Ignored. Error: %d",
+            dir, errno);
+      return NULL;
+
+    }
+    infof(data, "Already exists %s directory.", dir);
+  }
+  else
+  {
+    infof(data, "Created %s directory.", dir);
+  }
+  return dir;
+}
+
+/**
+ * Ensure th cache directory is accessible
+ * @param cache_dir cache directory
+ * @param data curl handle
+ * @return cache directory name or NULL
+ */
+char* ensureCacheDir(char* cache_dir, struct Curl_easy *data)
+{
+#ifdef __linux__
+  char *home_env = getenv("HOME");
+  strcpy(cache_dir, (home_env == NULL ? (char*)"/tmp" : home_env));
+
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "/.cache");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "/snowflake");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+#elif defined(__APPLE__)
+  char *home_env = getenv("HOME");
+  strcpy(cache_dir, (home_env == NULL ? (char*)"/tmp" : home_env));
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "/Library");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "/Caches");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "/Snowflake");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+#elif  defined(_WIN32)
+  char *home_env = getenv("USERPROFILE");
+  if (home_env == NULL)
+  {
+    home_env = getenv("TMP");
+	if (home_env == NULL)
+    {
+      home_env = getenv("TEMP");
+    }
+  }
+  strcpy(cache_dir, (home_env == NULL ? (char*)"c:\\temp" : home_env));
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "\\AppData");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "\\Local");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "\\Snowflake");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+  strcat(cache_dir, "\\Caches");
+  if (mkdirIfNotExists(cache_dir, data) == NULL)
+  {
+    goto err;
+  }
+#endif
+  infof(data, "OCSP cache file directory: %s", cache_dir);
+  return cache_dir;
+err:
+  return NULL;
+}
+
+/**
+ * Write OCSP cache onto a file in the cache directory
+ * @param data curl handle
+ */
+void writeOCSPCacheFile(struct Curl_easy* data)
+{
+  char cache_dir[PATH_MAX] = "";
+  char cache_file[PATH_MAX] = "";
+  char cache_lock_file[PATH_MAX] = "";
+  FILE *fh;
+  FILE *fp;
+  char * jsonText;
+
+  _mutex_lock(&ocsp_response_cache_mutex);
+  if (ocsp_cache_root == NULL)
+  {
+      infof(data, "Skipping writing OCSP cache file as no OCSP cache root exists.");
+      goto end;
+  }
+
+  if (ensureCacheDir(cache_dir, data) == NULL)
+  {
+    failf(data, "The cache file is not accessible.");
+    goto end;
+  }
+
+  /* cache file */
+  strcpy(cache_file, cache_dir);
+  strcat(cache_file, PATH_SEP);
+  strcat(cache_file, OCSP_RESPONSE_CACHE_JSON);
+  infof(data, "OCSP Cache file: %s", cache_file);
+
+  /* cache lock directory/file */
+  strcpy(cache_lock_file, cache_file);
+  strcat(cache_lock_file, ".lck");
+
+  if (access(cache_lock_file, F_OK) != -1)
+  {
+    /* lck file exists */
+    struct stat statbuf;
+    if (stat(cache_lock_file, &statbuf) != -1)
+    {
+      if ((long)time(NULL) - (long) statbuf.st_mtime < 60*60)
+      {
+        infof(data, "Other process lock the file, ignored");
+        goto end;
+      }
+      else
+      {
+        infof(data, "Remove the old lock file");
+        if (remove(cache_lock_file) != 0)
+        {
+          infof(data, "Failed to delete the lock file: %s, ignored", cache_lock_file);
+          goto end;
+        }
+      }
+    }
+  }
+
+  /* create a new lck file */
+  fh = fopen(cache_lock_file, "w");
+  if (fh == NULL)
+  {
+    infof(data, "Failed to create a lock file: %s. Skipping writing OCSP cache file.",
+        cache_lock_file);
+    goto end;
+  }
+  if (fclose(fh) != 0)
+  {
+    infof(data, "Failed to close a lock file: %s. Ignored.", cache_lock_file);
+    goto end;
+  }
+
+  fp = fopen(cache_file, "w");
+  if (fp == NULL)
+  {
+    infof(data, "Failed to open OCSP response cache file. Skipping writing OCSP cache file.");
+    goto end;
+  }
+  jsonText = sf_curl_cJSON_PrintUnformatted(ocsp_cache_root);
+  if (fprintf(fp, "%s", jsonText) < 0)
+  {
+    infof(data, "Failed to write OCSP response cache file. Skipping");
+  }
+
+  if (fclose(fp) != 0)
+  {
+    infof(data, "Failed to close OCSP response cache file: %s. Ignored", cache_file);
+  }
+  infof(data, "Write OCSP Response to cache file");
+
+  /* deallocate json string */
+  sf_curl_cJSON_free(jsonText);
+
+  if (remove(cache_lock_file) != 0)
+  {
+    infof(data, "Failed to delete the lock file: %s, ignored", cache_lock_file);
+  }
+end:
+  if (ocsp_cache_root != NULL)
+  {
+    sf_curl_cJSON_Delete(ocsp_cache_root);
+    ocsp_cache_root = NULL;
+  }
+  _mutex_unlock(&ocsp_response_cache_mutex);
+}
+
+/**
+ * Read OCSP cache from from the local cache directory
+ * @param data curl handle
+ */
+void readOCSPCacheFile(struct Curl_easy* data, SF_OTD *ocsp_log_data)
+{
+  char cache_dir[PATH_MAX] = "";
+  char cache_file[PATH_MAX] = "";
+  char *ocsp_resp_cache_str = NULL;
+  FILE* pfile = NULL;
+#ifdef _WIN32
+  struct _stat statbuf;
+#else
+  struct stat statbuf;
+#endif
+
+  _mutex_lock(&ocsp_response_cache_mutex);
+
+  if (ensureCacheDir(cache_dir, data) == NULL)
+  {
+    infof(data, "Could not ensure the presence of Cache Directory. "
+                "Skipping reading cache. Driver will try to download"
+                "the cache from the Cache Server directly.");
+    sf_otd_set_event_sub_type(OCSP_CACHE_READ_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  /* cache file */
+  strcpy(cache_file, cache_dir);
+  strcat(cache_file, PATH_SEP);
+  strcat(cache_file, OCSP_RESPONSE_CACHE_JSON);
+  infof(data, "OCSP cache file: %s", cache_file);
+
+  if (ocsp_cache_root != NULL)
+  {
+    infof(data, "OCSP cache was already read onto memory");
+    goto end;
+  }
+  if (access(cache_file, F_OK) == -1)
+  {
+    infof(data, "No OCSP cache file found on disk. file: %s", cache_file);
+    sf_otd_set_event_sub_type(OCSP_CACHE_READ_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  /* get file size */
+#ifdef _WIN32
+  if (_stat(cache_file, &statbuf) != 0)
+#else
+  if (stat(cache_file, &statbuf) != 0)
+#endif
+  {
+    infof(data, "Failed to get cache file size. file: %s", cache_file);
+    sf_otd_set_event_sub_type(OCSP_CACHE_READ_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  /* initialize read buffer */
+  ocsp_resp_cache_str = (char *)malloc(statbuf.st_size + 1);
+  if (ocsp_resp_cache_str == NULL)
+  {
+    infof(data, "Failed to allocate buffer for OCSP cache file. file: %s", cache_file);
+    sf_otd_set_event_sub_type(OCSP_CACHE_READ_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  pfile = fopen(cache_file, "r");
+  if (pfile == NULL)
+  {
+    infof(data, "Failed to open OCSP response cache file. Ignored.");
+    sf_otd_set_event_sub_type(OCSP_CACHE_READ_FAILURE, ocsp_log_data);
+    goto end;
+  }
+
+  if (fgets(ocsp_resp_cache_str, statbuf.st_size + 1, pfile) == NULL) {
+    infof(data, "Failed to read OCSP response cache file. Ignored");
+    goto file_close;
+  }
+  /* just attached the whole JSON object */
+  ocsp_cache_root = sf_curl_cJSON_Parse(ocsp_resp_cache_str);
+  if (ocsp_cache_root == NULL)
+  {
+    infof(data, "Failed to parse cache file content in json format");
+    sf_otd_set_event_sub_type(OCSP_CACHE_READ_FAILURE, ocsp_log_data);
+  }
+  else
+  {
+    infof(data, "OCSP cache file was successfully loaded");
+  }
+file_close:
+  if (fclose(pfile) != 0)
+  {
+    infof(data, "Failed to close cache file. Ignored.");
+    goto end;
+  }
+end:
+  if (ocsp_cache_root == NULL) ocsp_cache_root = sf_curl_cJSON_CreateObject();
+  if (ocsp_resp_cache_str != NULL) free(ocsp_resp_cache_str);
+  _mutex_unlock(&ocsp_response_cache_mutex);
+  return;
+}
+
+/**
+ * Initialize OCSP Cache Server
+ * @param data curl handle
+ */
+void initOCSPCacheServer(struct Curl_easy *data)
+{
+  char* ocsp_cache_server_enabled_env = NULL;
+  int ACTIVATE_SSD = checkSSDStatus();
+  /* OCSP cache server URL */
+  _mutex_lock(&ocsp_response_cache_mutex);
+    ocsp_cache_server_enabled_env = getenv(
+    "SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED");
+  if (ocsp_cache_server_enabled_env == NULL ||
+      strcmp(ocsp_cache_server_enabled_env, "false") != 0)
+  {
+    /* OCSP Cache server enabled by default */
+    ocsp_cache_server_enabled = 1;
+  }
+
+  ocsp_cache_server_url_env = getenv(
+    "SF_OCSP_RESPONSE_CACHE_SERVER_URL");
+
+  // TEST ENABLED
+  if (getTestStatus(SF_OCSP_TEST_MODE) == TEST_ENABLED)
+  {
+    char *test_cache_server_url = getenv("SF_TEST_OCSP_CACHE_SERVER_URL");
+    printTestWarning(data);
+    if (test_cache_server_url)
+    {
+      failf(data, "Forced Behavior - Cache Server URL.");
+      snprintf(ocsp_cache_server_url, sizeof(ocsp_cache_server_url),
+               "%s", test_cache_server_url);
+      goto end;
+    }
+  }
+
+  if (ocsp_cache_server_url_env == NULL)
+  {
+    char* top_domain = strrchr(data->conn->host.name, '.');
+    if (top_domain)
+    {
+      top_domain++;
+    }
+    else
+    {
+      // It's basically impossible not finding top domain in host.
+      // Use "com" as default just in case.
+      top_domain = "com";
+    }
+
+    /* default URL */
+    snprintf(default_ocsp_cache_host, sizeof(default_ocsp_cache_host),
+             DEFAULT_OCSP_RESPONSE_CACHE_HOST, top_domain);
+    snprintf(ocsp_cache_server_url, sizeof(ocsp_cache_server_url),
+             OCSP_RESPONSE_CACHE_URL,
+             default_ocsp_cache_host,
+             OCSP_RESPONSE_CACHE_JSON);
+
+    if (!ACTIVATE_SSD)
+    {
+      strncpy(ocsp_cache_server_retry_url_pattern,
+              "%s/%s", sizeof(ocsp_cache_server_retry_url_pattern));
+    }
+    else
+    {
+      /*
+       * Non private link customers always go to default
+       * retry URL for OCSP retries
+       */
+      snprintf(default_ocsp_cache_retry_url, sizeof(default_ocsp_cache_retry_url),
+               OCSP_RESPONDER_RETRY_URL, top_domain);
+      strncpy(ocsp_cache_server_retry_url_pattern,
+              default_ocsp_cache_retry_url,
+              strlen(default_ocsp_cache_retry_url) + 1);
+    }
+  }
+  else
+  {
+    // if specified, always use the special retry url
+    int use_ssl;
+    char *host = NULL, *port = NULL, *path = NULL;
+    strncpy(ocsp_cache_server_url, ocsp_cache_server_url_env,
+            sizeof(ocsp_cache_server_url));
+    ocsp_cache_server_url[sizeof(ocsp_cache_server_url) - 1] = '\0';
+    OCSP_parse_url(
+            ocsp_cache_server_url_env, &host, &port, &path, &use_ssl);
+
+    if (!ACTIVATE_SSD)
+    {
+      snprintf(ocsp_cache_server_retry_url_pattern,
+               sizeof(ocsp_cache_server_retry_url_pattern),
+               "%s://%s:%s/retry/%%s/%%s", use_ssl ? "https" : "http", host, port);
+    }
+    else
+    {
+      snprintf(ocsp_cache_server_retry_url_pattern,
+               sizeof(ocsp_cache_server_retry_url_pattern),
+               "%s://%s:%s/retry", use_ssl ? "https" : "http", host, port);
+    }
+
+    if (getTestStatus(SF_OCSP_TEST_MODE) == TEST_ENABLED)
+    {
+      char *test_cache_server_url = getenv("SF_TEST_OCSP_CACHE_SERVER_URL");
+      printTestWarning(data);
+      if (test_cache_server_url)
+      {
+        failf(data, "Forced Behavior - Cache Server URL.");
+        snprintf(ocsp_cache_server_url, sizeof(ocsp_cache_server_url),
+                 "%s", test_cache_server_url);
+      }
+    }
+
+    OPENSSL_free(host);
+    OPENSSL_free(path);
+    OPENSSL_free(port);
+  }
+
+  end:
+  infof(data, "SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED: %s",
+    ocsp_cache_server_enabled ? "true" : "false");
+  infof(data, "SF_OCSP_RESPONSE_CACHE_SERVER_URL: %s",
+    ocsp_cache_server_url);
+  _mutex_unlock(&ocsp_response_cache_mutex);
+}
+
+/**
+ * Initialize Check OCSP revocation status method
+ */
+SF_PUBLIC(CURLcode) initCertOCSP()
+{
+  /* must call only once. not thread safe */
+  _mutex_init(&ocsp_response_cache_mutex);
+  atexit(termCertOCSP);
+  return CURLE_OK;
+}
+
+/**
+ * Terminate Check OCSP revocation status method
+ */
+static void termCertOCSP()
+{
+  /* terminate the mutex */
+  _mutex_term(&ocsp_response_cache_mutex);
+}
+
+/**
+ * Main entry point. Check OCSP revocation status.
+ * @param conn Curl connection
+ * @param ch a chain of certificates
+ * @param st CA trust
+ * @param ocsp_failopen_cnxn_param connection param setting for
+ * failopen. This should be a binary value - either True or False
+ * There is no option for this to be in a NOTSET state.
+ * @param oob_enable param setting for enable oob telemetry.
+ * @return Curl return code
+ */
+SF_PUBLIC(CURLcode) checkCertOCSP(struct connectdata *conn,
+                                  struct Curl_easy *data,
+                                  STACK_OF(X509) *ch,
+                                  X509_STORE *st,
+                                  int ocsp_failopen_cnxn_param,
+                                  bool oob_enable)
+{
+  int numcerts;
+  int i;
+  CURLcode rs = CURLE_OK;
+  char *ocsp_fail_open_env = getenv("SF_OCSP_FAIL_OPEN"); // Testing Only
+  SF_FAILOPEN_STATUS ocsp_fail_open = ENABLED;
+  char last_timeout_host[MAX_BUFFER_LENGTH];
+  last_timeout_host[0] = '\0';
+  // SNOW-1526511 ignore top level domain name to be more flexible
+  const char* telemetry_endpoints[] = {
+    "sfctest.client-telemetry.snowflakecomputing.",
+    "sfcdev.client-telemetry.snowflakecomputing.",
+    "client-telemetry.snowflakecomputing."
+  };
+  const int telemetry_endpoints_num = sizeof(telemetry_endpoints) / sizeof(char*);
+
+// These end points are Out of band telemetry end points.
+// Do not use OCSP/failsafe on Out of band telemetry endpoints
+  for (int i = 0; i < telemetry_endpoints_num; i++)
+  {
+    if (strncasecmp(conn->host.name, telemetry_endpoints[i], strlen(telemetry_endpoints[i])) == 0)
+    {
+      return rs;
+    }
+  }
+
+  SF_OTD ocsp_log_data;
+  memset(&ocsp_log_data, 0, sizeof(SF_OTD));
+
+  if (ocsp_fail_open_env != NULL)
+  {
+    /*
+     * OCSP Fail Open Env Variable is for internal usage/ testing only.
+     * Using it in production is not advised and not supported.
+     */
+    if(strncmp(ocsp_fail_open_env, "false", 5) != 0)
+    {
+      ocsp_fail_open = ENABLED;
+    }
+    else
+    {
+      ocsp_fail_open = DISABLED;
+    }
+  }
+  else if (ocsp_failopen_cnxn_param)
+  {
+    ocsp_fail_open = ENABLED;
+  }
+  else
+  {
+    ocsp_fail_open = DISABLED;
+  }
+
+  sf_otd_set_insecure_mode(0, &ocsp_log_data);
+
+  infof(data, "Cert Data Store: %s, Certifcate Chain: %s", (char*)st, (char*)ch);
+  initOCSPCacheServer(data);
+
+  infof(data, "Start SF OCSP Validation...");
+  readOCSPCacheFile(data, &ocsp_log_data);
+
+  numcerts = sk_X509_num(ch);
+  infof(data, "Number of certificates in the chain: %d", numcerts);
+  /* Only check end-entity by default to avoid cross-signed CA pitfalls.
+   * Set SF_OCSP_CHECK_INTERMEDIATES=true to also check intermediates. */
+  int check_intermediates = parse_bool_env("SF_OCSP_CHECK_INTERMEDIATES");
+  int last_index = check_intermediates ? (numcerts - 1) : 1; /* only i=0 when false */
+  for (i = 0; i < last_index; i++)
+  {
+    X509* cert = sk_X509_value(ch, i);
+    X509* issuer = sk_X509_value(ch, i+1);
+
+    rs = checkOneCert(cert, issuer, ch, st, ocsp_fail_open, conn, data, &ocsp_log_data, oob_enable, last_timeout_host);
+    if (rs != CURLE_OK)
+    {
+      goto end;
+    }
+  }
+  writeOCSPCacheFile(data);
+end:
+  infof(data, "End SF OCSP Validation... Result: %d", rs);
+  return rs;
+}
\ No newline at end of file
diff --git a/deps/curl/lib/vtls/sf_ocsp.h b/deps/curl/lib/vtls/sf_ocsp.h
new file mode 100644
index 000000000..26b9ae7b5
--- /dev/null
+++ b/deps/curl/lib/vtls/sf_ocsp.h
@@ -0,0 +1,23 @@
+#ifndef HEADER_CURL_SF_OCSP_H
+#define HEADER_CURL_SF_OCSP_H
+
+#include "urldata.h"
+#include <openssl/ssl.h>
+#include <openssl/ocsp.h>
+
+#ifdef _WIN32
+#define SF_PUBLIC(type)   __declspec(dllexport) type __stdcall
+#else
+#define SF_PUBLIC(type) type
+#endif
+
+SF_PUBLIC(CURLcode) initCertOCSP();
+SF_PUBLIC(CURLcode) checkCertOCSP(struct connectdata *conn,
+                                  struct Curl_easy *data,
+                                  STACK_OF(X509) *ch,
+                                  X509_STORE *st,
+                                  int ocsp_failopen,
+                                  bool oob_enable);
+
+#endif
+
diff --git a/deps/curl/lib/vtls/vtls.c b/deps/curl/lib/vtls/vtls.c
index f17f9142b..4ab4bf505 100644
--- a/deps/curl/lib/vtls/vtls.c
+++ b/deps/curl/lib/vtls/vtls.c
@@ -394,6 +394,15 @@ void Curl_ssl_conn_config_update(struct Curl_easy *data, bool for_proxy)
     dest->verifyhost = src->verifyhost;
     dest->verifypeer = src->verifypeer;
     dest->verifystatus = src->verifystatus;
+    dest->sf_ocsp_check = src->sf_ocsp_check;
+    dest->sf_ocsp_failopen = src->sf_ocsp_failopen;
+    dest->sf_crl_check = src->sf_crl_check;
+    dest->sf_crl_advisory = src->sf_crl_advisory;
+    dest->sf_crl_allow_no_crl = src->sf_crl_allow_no_crl;
+    dest->sf_crl_disk_caching = src->sf_crl_disk_caching;
+    dest->sf_crl_memory_caching = src->sf_crl_memory_caching;
+    dest->sf_crl_download_timeout = src->sf_crl_download_timeout;
+    dest->sf_oob_enable = src->sf_oob_enable;
   }
 }
 
diff --git a/deps/curl/src/tool_version.h b/deps/curl/src/tool_version.h
index 00be7799e..6ab8afd63 100644
--- a/deps/curl/src/tool_version.h
+++ b/deps/curl/src/tool_version.h
@@ -27,7 +27,7 @@
 
 #define CURL_NAME "curl"
 #define CURL_COPYRIGHT LIBCURL_COPYRIGHT
-#define CURL_VERSION LIBCURL_VERSION
+#define CURL_VERSION "8.16.0"
 #define CURL_VERSION_MAJOR LIBCURL_VERSION_MAJOR
 #define CURL_VERSION_MINOR LIBCURL_VERSION_MINOR
 #define CURL_VERSION_PATCH LIBCURL_VERSION_PATCH
